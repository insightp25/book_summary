# 아이템 86 - Serializable을 구현할지는 신중히 결정하라

## 요약

> Serializable은 구현한다고 선언하기는 쉽지만, 제한된 환경에서 사용될 클래스가 아니라면 아주 신중하게 이뤄져야 한다. 상속할 수 있는 클래스는 주의사항이 더욱 많아진다.

## 배경

어턴 클래스의 인스턴스를 직렬화할 수 있게 하려면 클래스 선언에 `implements Serializable`만 덧붙이면 된다.

직렬화는 장기적 관점에서 아주 값비싼 일이다.


## `Serializable` 구현의 문제점들

### 1. Serializable을 구현하면 릴리스 뒤에는 수정하기 어렵다.

커스텀 직렬화 형태를 설계하지 않고 자바의 기본 방식을 사용하면 당시 클래스의 내부 구현 방식에 영원히 묶여버린다.

기본 직렬화 형태에서는 클래스의 `private`과 `package-private` 인스턴스 필드들마저 API로 공개되는 꼴이 된다(캡슐화가 깨진다).

직렬화 가능 클래스를 만들고자 한다면, 길게 보고 감당할 수 있을 만큼 고품질의 직렬화 형태도 주의해서 함께 설계해야 한다.


### 2. `Serializable` 구현의 두 번째 문제는 버그와 보안 구멍이 생길 위험이 높아진다는 점

객체는 생성자를 사용해 만드는게 기본. 직렬화는 언어의 기본 매커니즘을 우회하는 객체 생성 기법이다.

역직렬화는 일반 생성자의 문제가 그대로 적용되는 '숨은 생성자'다.


### 3. 해당 클래스의 신버전을 릴리스할 때 테스트할 것이 늘어난다.

신버진 인스턴스 직렬화 후 구버전으로 역직렬화할 수 있는지, 그 반대도 가능한지 검사해야 한다. -> 테스트 양이 직렬화 가능 클래스의 수와 릴리스 횟수에 비례해 증가한다.


## 그 외

- 역사적으로 `BigInteger`와 `Integer` 같은 '값' 클래스와 컬렉션 클래스들은 `Serializable`을 구현하고, 스레드 풀처럼 '동작'하는 객체를 표현하는 클래스들은 구현하지 않는다.
- 상속용으로 설계된 클래스와 인터페이스 대부분 `Serializable`을 확장해서는 안 된다. -> 할 시 클래스 확장/인터페이스 구현 클래스에 큰 부담을 지우게 된다.

- 







