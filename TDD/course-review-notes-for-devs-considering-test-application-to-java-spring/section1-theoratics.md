# 섹션1. 이론 수업

# 실기로 배우는 간단한 테스트 작성 방법 소개

- VO의 특징 중 하나: VO 안의 변수들은 값이 항상 유효하다 -> VO 내에서 필드 유효성 검증(eg. 입력 개수 등)



<br><br>

# 테스트에 대한 개요와 개발자가 해야할 고민

## 1. 테스트란?

- 인수 테스트 - 사람이 직접 사용해 보면서 준비된 체크리스트를 확인
- 자동 테스트 - 미리 짜여진 테스트 코드를 돌려서 결과값과 예상값을 비교하는 자동 테스트

<br>

## 2. TDD

### 테스트 주도 개발

1. red - 깨지는 테스트를 먼저 작성한다.
  - 테스트가 실패하는지까지 제대로 확인해야 한다.
2. green - 깨지는 테스트를 성공시킨다.
  - 실제로 구현 진행
3. blue - 리팩토링 한다.
  - 복잡한 코드에서는 이 과정이 파괴적일 수 있다.

TDD는 이 과정을 모든 개발 단계에서, 무한히 반복한다.


### 테스트 주도 개발의 장단점

장점

1. 깨지는 테스트를 먼저 작성해야하기 때문에, 인터페이스를 먼저 만드는 것이 강제된다.
  - 객체들이 어떤 책임을 지고, 이 객체는 어디까지 해줘야 하는지를 먼저 생각하게 만든다. -> 어마어마한 장점인 게, 인터페이스에 주목한다는 것은 객체지향의 핵심 원리 중 하나인 행동에 집중하겠다는 말과 같기 때문이다.
  - TDD가 책임-주도 설계의 핵심 과정인 'what/who 사이클을 고민하게 도와준다'
    - what/who 사이클: 어떤 행위를 누가 수행할지 결정하는 과정. 
    - "객체 사이의 협력 관계를 설계하기 위해서는 먼저 '어떤 행위(what)'를 수행할 것인지를 결정한 후에 '누가(who)' 그 행위를 수행할 것인지를 결정해야 한다는 것이다. 여기서 '어떤 행위'가 바로 메시지다." - 객체지향의 사실과 오해, 조영호
2. 장기적인 관점에서 개발 비용 감소

단점

1. 초기 개발 비용
  - 요구사항이 명확하지 않거나, 서비스의 흥망성쇠가 눈에 보이지 않는 경우에는 이 방법을 적용하기 다소 어려울 수 있다(eg. 스타트업).
2. 난이도

<br>

## 3. 개발자의 고민

1. 무의미한 테스트
  - 장점1 깨지는 테스트를 먼저 작성해야하기 때문에, 인터페이스를 먼저 만드는 것이 강제된다. -> 그 덕분에 개발자는 '행동에 집중할 수 있게 된다.'
  - 여기서 행동이란 메서드나 함수를 의미하는 게 아니다 -> 모든 메서드를 테스트하기 보다는 중요 로직을 잘 구분해 테스트를 하는 게 더 낫다(의견).
2. 느리고 쉽게 깨지는 테스트
  - eg. H2로 가장 간단한 테스트시 300ms 정도 걸릴시 * 200개 -> 1분 소요
  - eg2. 아무 변경 없을 때 실패해서 2시간 디버깅 했는데 h2 문제...
  - eg3. 테스트 간의 병렬 처리를 제대로 다루지 못해서 테스트 실패
3. 테스트가 불가한 코드
  - eg. 로그인 검증 테스트시 로그인 당시 시간을 검증 당시에 어떻게 검증할 수 있을까?
    - mock 등을 활용해 어떻게든 할 수 있지만...
    - 이건 신호이다. 테스트를 못하니까 설계가 잘못되었다는 뜻이기도 하다. -> 그런데 이 기회를 포착하지 않고, mock 라이브러리로 강제로 테스트를 넣으면 설계를 발전시킬 수 있는 기회를 놓치게 되는 것이다.

### 고민을 통한 개선

테스트는 좋은 설계를 유도한다.
- 개발자는 테스트를 짜면서 여러 고민들을 하게 되고, 이런 고민들이 모두 테스트가 보내는 신호이다 -> 이러한 신호를 잘 포착해 개선하고, 좋은 설계를 얻어야 한다.


### 인용

- 조영호 저, 객체지향의 사실과 오해 역할, 책임, 협력 관점에서 본 객체지향, , (위키북스, 2018-07-31), 158p







<br><br>

# 테스트의 필요성과 테스트 3분류

## 1. 테스트의 필요성

### 레거시 코드

- 레거시 코드
  - "내게 레거시 코드란, 단순히 테스트 루틴이 없는 코드다. 다만 이정의는 다소 불환전하다" - 마이클 페더스
  - 어제 짠 코드라고 해도 테스트가 없다면 레거시
  - 한 달 전도, 어제 짠 코드도 레거시가 될 수 있다. 엄밀히 말해 시간과는 관계가 없다.

### regression

regression: 잘 돌아가는 코드가 새로운 배포로 인해 동작하지 않는 상황
- regression은 생각보다 굉장히 큰 문제이다. 단순한 심리 문제 이상의 영역. 서비스 품질과 직결. 
- 구글에서도 불안에 떨며 릴리즈 -> 자동 테스트 도입


### 좋은 아키텍처 유도

> SOLID

SOLID와 테스트는 생각보다 굉장히 긴밀한 상관관계를 갖는다. 서로가 서로에게 상호보완적이다.
- SOLID가 지켜지면 경계가 만들어진다 <-> 회귀버그 발생을 막을 수 있다

좋은 아키텍처란? 상호보완적

- 단일 책임 원칙(SRP)
  - 테스트는 명료하고 간단하게 작성해야 -> 테스트가 너무 많아져 무슨 목적의 클래스인지 눈에 안들어오게 된다 -> 클래스 분할 -> 자연스럽게 책임 분배

- 개방 폐쇄 원칙(OCP)
  - 테스트 컴포넌트와 프로덕션 컴포넌트를 나눠 작업하게 되고 필요에 따라 이 컴포넌트를 자유자재로 탈부탁 가능하게 개발하게 된다
  - 컴포넌트간 서로에게 영향을 주면 안된다.
  - 이 과정에서 프로덕션 코드가 OCP를 지키게 된다

- 리스코프 치환 원칙(LSP)
  - 이상적으로는 테스트는 모든 케이스에 대해 커버하고 있으므로, 서브 클래스에 대한 치환 여부를 테스트가 알아서 판단해준다.

- 인터페이스 분리 원칙(ISP)
  - 테스트는 그 자체로 인터페이스를 직접 사용해볼 수 있는 환경
  - 불필요한 의존성을 실제로 확인할 수 있는 샌드박스

- 의존성 역전 원칙(DIP)
  - 가짜 객체를 이용하여 테스트를 작성하려면, 의존성이 역전되어 있어야 하는 경우가 생김

테스트가 SOLID를 강제하는 것은 아니다. 테스트를 넣으면서 이런 것도 함께 챙겨줘야 한다는 의미.


### 테스트 가능 설계

테스트의 가치
- 품질 보증을 위한 도구
- 설계를 위한 도구 -> 가치 크게 증가


<br>

## 2. 테스트의 3분류

### 전통적인 테스트 3분류

1. E2E(5%) -> API 테스트
2. Integration(15%) -> 통합 테스트
3. Unit(80%) -> 단위 테스트

사람마다 정의 상의, 구분 기준 모호

### 구글의 테스트 3분류

1. E2E(5%) -> large(대형) test
  - 멀티 서버
  - end to end 테스트
2. Integration(15%) -> medium(중형) test
  - 조건
    - 단일 서버
    - 멀티 프로세스
    - 멀티 스레드
  - (-> h2같은 테스트 DB 사용 가능)
  - 당연하게도 소형 테스트보다 느리고 멀티스레드 환경에서 어떻게 동작할지 모르기 때문에 결과가 항상 같다는 보장을 하지 못한다. 테스트가 h2같은 외부 모듈의 동작에 따라서 달라지기 때문.
  - 중형 테스트를 너무 많이 만드는 실수는 스프링 개발자들이 정말 많이 저지르는 실수이기도 하다. 모든 테스트가 h2를 사용하고 있고, 그래서 모든 테스트가 중형 테스트이다.
3. Unit(80%) -> small(소형) test
  - 조건
    - 단일 서비
    - 단일 프로세스
    - 단일 스레드
    - 디스크 I/O 사용해선 안됨
    - blocking call 허용 안됨
  - 그래서 스레드 슬립이 테스트에 있으면 소형 테스트가 아니다.
  - 이런 조건들 때문에 소형 테스트는 항상 결과가 결정적이고 속도가 빨라진다.

당연하게도 우리가 집중해야 하는 것은 소형 테스트이다.


### 인용

- 마이클 C. 페더스, 레거시 코드 활용 전략 손대기 두려운 낡은 코드, 안전한 변경과 테스트 기법, 심윤보 이정문 옮김, (에이콘, 2018-09-18), 12p
- 타이터스 윈터스, 톰 맨쉬렉, 하이럼 라이트 큐레이션, 구글 엔지니어는 이렇게 일한다 구글러가 전하는 문화, 프로세스, 도구의 모든 것, 개앞맵시 역, (한빛미디어, 2022-05-10), 283p
- Effective Unit Testing 클린 코드와 좋은 설계를 이끄는 단위 테스트
- Curated by Titus Winters, Tom manshreck & Hyrum Wright, Software Engineering at Google: Lessons Learned from Programming Over Time, (O'Reilly Media, 2020-09-04)







<br><br>

# 테스트에 필요한 개념











### 인용

- Wikipedia contributors, "Behavior-driven development," Wikipedia, The Free Encyclopedia, https://en.wikipedia.org/w/index.php?title=Behavior-driven_development&oldid=1138005827 (accessed February 13, 2023).
- 타이터스 윈터스, 톰 맨쉬렉, 하이럼 라이트 큐레이션, 구글 엔지니어는 이렇게 일한다 구글러가 전하는 문화, 프로세스, 도구의 모든 것, 개앞맵시 역, (한빛미디어, 2022-05-10), 366p
- 마티아스 노박, 오브젝트 디자인 스타일 가이드 팀의 생산성을 높이는 고품질 객체지향 코드 작성법, 이상주 역, (위키북스, 2022), 28p
- 마티아스 노박, 오브젝트 디자인 스타일 가이드 팀의 생산성을 높이는 고품질 객체지향 코드 작성법, 이상주 역, (위키북스, 2022), 231p





<br><br>

# 









<br><br>

# 







<br><br>

# 








<br><br>

# 




