# 섹션1. 이론 수업

# 실기로 배우는 간단한 테스트 작성 방법 소개

- VO의 특징 중 하나: VO 안의 변수들은 값이 항상 유효하다 -> VO 내에서 필드 유효성 검증(eg. 입력 개수 등)



<br><br>

# 테스트에 대한 개요와 개발자가 해야할 고민

## 1. 테스트란?

- 인수 테스트 - 사람이 직접 사용해 보면서 준비된 체크리스트를 확인
- 자동 테스트 - 미리 짜여진 테스트 코드를 돌려서 결과값과 예상값을 비교하는 자동 테스트

<br>

## 2. TDD

### 테스트 주도 개발

1. red - 깨지는 테스트를 먼저 작성한다.
  - 테스트가 실패하는지까지 제대로 확인해야 한다.
2. green - 깨지는 테스트를 성공시킨다.
  - 실제로 구현 진행
3. blue - 리팩토링 한다.
  - 복잡한 코드에서는 이 과정이 파괴적일 수 있다.

TDD는 이 과정을 모든 개발 단계에서, 무한히 반복한다.


### 테스트 주도 개발의 장단점

장점

1. 깨지는 테스트를 먼저 작성해야하기 때문에, 인터페이스를 먼저 만드는 것이 강제된다.
  - 객체들이 어떤 책임을 지고, 이 객체는 어디까지 해줘야 하는지를 먼저 생각하게 만든다. -> 어마어마한 장점인 게, 인터페이스에 주목한다는 것은 객체지향의 핵심 원리 중 하나인 행동에 집중하겠다는 말과 같기 때문이다.
  - TDD가 책임-주도 설계의 핵심 과정인 'what/who 사이클을 고민하게 도와준다'
    - what/who 사이클: 어떤 행위를 누가 수행할지 결정하는 과정. 
    - "객체 사이의 협력 관계를 설계하기 위해서는 먼저 '어떤 행위(what)'를 수행할 것인지를 결정한 후에 '누가(who)' 그 행위를 수행할 것인지를 결정해야 한다는 것이다. 여기서 '어떤 행위'가 바로 메시지다." - 객체지향의 사실과 오해, 조영호
2. 장기적인 관점에서 개발 비용 감소

단점

1. 초기 개발 비용
  - 요구사항이 명확하지 않거나, 서비스의 흥망성쇠가 눈에 보이지 않는 경우에는 이 방법을 적용하기 다소 어려울 수 있다(eg. 스타트업).
2. 난이도

<br>

## 3. 개발자의 고민

1. 무의미한 테스트
  - 장점1 깨지는 테스트를 먼저 작성해야하기 때문에, 인터페이스를 먼저 만드는 것이 강제된다. -> 그 덕분에 개발자는 '행동에 집중할 수 있게 된다.'
  - 여기서 행동이란 메서드나 함수를 의미하는 게 아니다 -> 모든 메서드를 테스트하기 보다는 중요 로직을 잘 구분해 테스트를 하는 게 더 낫다(의견).
2. 느리고 쉽게 깨지는 테스트
  - eg. H2로 가장 간단한 테스트시 300ms 정도 걸릴시 * 200개 -> 1분 소요
  - eg2. 아무 변경 없을 때 실패해서 2시간 디버깅 했는데 h2 문제...
  - eg3. 테스트 간의 병렬 처리를 제대로 다루지 못해서 테스트 실패
3. 테스트가 불가한 코드
  - eg. 로그인 검증 테스트시 로그인 당시 시간을 검증 당시에 어떻게 검증할 수 있을까?
    - mock 등을 활용해 어떻게든 할 수 있지만...
    - 이건 신호이다. 테스트를 못하니까 설계가 잘못되었다는 뜻이기도 하다. -> 그런데 이 기회를 포착하지 않고, mock 라이브러리로 강제로 테스트를 넣으면 설계를 발전시킬 수 있는 기회를 놓치게 되는 것이다.

### 고민을 통한 개선

테스트는 좋은 설계를 유도한다.
- 개발자는 테스트를 짜면서 여러 고민들을 하게 되고, 이런 고민들이 모두 테스트가 보내는 신호이다 -> 이러한 신호를 잘 포착해 개선하고, 좋은 설계를 얻어야 한다.


### 인용

- 조영호 저, 객체지향의 사실과 오해 역할, 책임, 협력 관점에서 본 객체지향, , (위키북스, 2018-07-31), 158p












<br><br>

# 테스트의 필요성과 테스트 3분류

## 1. 테스트의 필요성

### 레거시 코드

- 레거시 코드
  - "내게 레거시 코드란, 단순히 테스트 루틴이 없는 코드다. 다만 이정의는 다소 불환전하다" - 마이클 페더스
  - 어제 짠 코드라고 해도 테스트가 없다면 레거시
  - 한 달 전도, 어제 짠 코드도 레거시가 될 수 있다. 엄밀히 말해 시간과는 관계가 없다.

### regression

regression: 잘 돌아가는 코드가 새로운 배포로 인해 동작하지 않는 상황
- regression은 생각보다 굉장히 큰 문제이다. 단순한 심리 문제 이상의 영역. 서비스 품질과 직결. 
- 구글에서도 불안에 떨며 릴리즈 -> 자동 테스트 도입


### 좋은 아키텍처 유도

> SOLID

SOLID와 테스트는 생각보다 굉장히 긴밀한 상관관계를 갖는다. 서로가 서로에게 상호보완적이다.
- SOLID가 지켜지면 경계가 만들어진다 <-> 회귀버그 발생을 막을 수 있다

좋은 아키텍처란? 상호보완적

- 단일 책임 원칙(SRP)
  - 테스트는 명료하고 간단하게 작성해야 -> 테스트가 너무 많아져 무슨 목적의 클래스인지 눈에 안들어오게 된다 -> 클래스 분할 -> 자연스럽게 책임 분배

- 개방 폐쇄 원칙(OCP)
  - 테스트 컴포넌트와 프로덕션 컴포넌트를 나눠 작업하게 되고 필요에 따라 이 컴포넌트를 자유자재로 탈부탁 가능하게 개발하게 된다
  - 컴포넌트간 서로에게 영향을 주면 안된다.
  - 이 과정에서 프로덕션 코드가 OCP를 지키게 된다

- 리스코프 치환 원칙(LSP)
  - 이상적으로는 테스트는 모든 케이스에 대해 커버하고 있으므로, 서브 클래스에 대한 치환 여부를 테스트가 알아서 판단해준다.

- 인터페이스 분리 원칙(ISP)
  - 테스트는 그 자체로 인터페이스를 직접 사용해볼 수 있는 환경
  - 불필요한 의존성을 실제로 확인할 수 있는 샌드박스

- 의존성 역전 원칙(DIP)
  - 가짜 객체를 이용하여 테스트를 작성하려면, 의존성이 역전되어 있어야 하는 경우가 생김

테스트가 SOLID를 강제하는 것은 아니다. 테스트를 넣으면서 이런 것도 함께 챙겨줘야 한다는 의미.


### 테스트 가능 설계

테스트의 가치
- 품질 보증을 위한 도구
- 설계를 위한 도구 -> 가치 크게 증가


<br>

## 2. 테스트의 3분류

### 전통적인 테스트 3분류

1. E2E(5%) -> API 테스트
2. Integration(15%) -> 통합 테스트
3. Unit(80%) -> 단위 테스트

사람마다 정의 상의, 구분 기준 모호

### 구글의 테스트 3분류

1. E2E(5%) -> large(대형) test
  - 멀티 서버
  - end to end 테스트
2. Integration(15%) -> medium(중형) test
  - 조건
    - 단일 서버
    - 멀티 프로세스
    - 멀티 스레드
  - (-> h2같은 테스트 DB 사용 가능)
  - 당연하게도 소형 테스트보다 느리고 멀티스레드 환경에서 어떻게 동작할지 모르기 때문에 결과가 항상 같다는 보장을 하지 못한다. 테스트가 h2같은 외부 모듈의 동작에 따라서 달라지기 때문.
  - 중형 테스트를 너무 많이 만드는 실수는 스프링 개발자들이 정말 많이 저지르는 실수이기도 하다. 모든 테스트가 h2를 사용하고 있고, 그래서 모든 테스트가 중형 테스트이다.
3. Unit(80%) -> small(소형) test
  - 조건
    - 단일 서비
    - 단일 프로세스
    - 단일 스레드
    - 디스크 I/O 사용해선 안됨
    - blocking call 허용 안됨
  - 그래서 스레드 슬립이 테스트에 있으면 소형 테스트가 아니다.
  - 이런 조건들 때문에 소형 테스트는 항상 결과가 결정적이고 속도가 빨라진다.

당연하게도 우리가 집중해야 하는 것은 소형 테스트이다.


<br>

## 인용

- 마이클 C. 페더스, 레거시 코드 활용 전략 손대기 두려운 낡은 코드, 안전한 변경과 테스트 기법, 심윤보 이정문 옮김, (에이콘, 2018-09-18), 12p
- 타이터스 윈터스, 톰 맨쉬렉, 하이럼 라이트 큐레이션, 구글 엔지니어는 이렇게 일한다 구글러가 전하는 문화, 프로세스, 도구의 모든 것, 개앞맵시 역, (한빛미디어, 2022-05-10), 283p
- Effective Unit Testing 클린 코드와 좋은 설계를 이끄는 단위 테스트
- Curated by Titus Winters, Tom manshreck & Hyrum Wright, Software Engineering at Google: Lessons Learned from Programming Over Time, (O'Reilly Media, 2020-09-04)











<br><br>

# 테스트에 필요한 개념

## 1. 개념

### SUT

- system under test(SUT) - 테스트하려는 대상
  - user 관련 검증 -> SUT는 user

### BDD

- behaviour driven development(given-when-then)
  - arrange-act-assert(3A)라고도 한다

BDD suggests that unit test names be whole sentences starting with a conditional verb("should" for example) and should be written in order of business value. Acceptance tests should be written using the standard agile framework of a user story

### 상호 작용 테스트(interaction test)

- 대상 함수의 구현을 호출하지 않으면서 그 함수가 어떻게 호출되는지를 검증하는 기법
  - 메서드가 실제로 호출이 됐는지를 검증하는 테스트
  - 일반적으로, 이렇게 메서드가 실제로 호출이 됐는지 검증하는 방법은 그다지 좋은 방법이 아니다. 왜냐하면 이게 내부 구현을 어떻게 했는지 '감시'하는 것이기 때문. 캡슐화 위배.
  - 객체한테 위임한 책임을, 이 객체가 제대로 수행했는지만 확인하면 되는데, 일을 이리 해라 저리해라 감시하는 것. 구현에 집착하는 것.
  - (개개인마다 호불호가 있다)

### 상태 검증 vs 행위 검증

- 상태 기반 검증(state-based verification)
  - input -> output
- 행위 기반 검증(behaviour-based verification) = 상호 작용 테스트

### 테스트 픽스처

- 테스트에 필요한 자원을 생성하는 것
  - fixture - 비품, 설비
  - 테스트 하기 위해 필요한 자원이 있다면 미리 생성해두는 것
  - 테스트가 한 눈에 잘 안들어와 왠만한 코드 중복이 발생하지 않는 한 잘 선호하지 않는다(의견).

### 비욘세 규칙

- 비욘세의 싱글 레이디 중
  - 네가 나를 좋아했다면, 프로포즈를 했었어야지
  - 상태를 유지하고 싶었다면, 테스트를 만들었어야지
- (구글에서 만든 규칙)
- "유지하고 싶은 상태나 정책이 있다면 전부 테스트로 작성해주세요. 그게 곧 정책이 될 겁니다."
  - eg. 유저 아이디가 이메일 형식이길 원하면, 유저 아이디가 이메일이 아닐 때 예외를 던지는 테스트를 작성
  - eg2. 마일리지 쿠폰이 5만원 이상일 때만 사용 가능하게 하고 싶다면, 5만 원 미만이면 예외를 던지는 그런 테스트를 작성
  - 이런 것들이 모여 시스템의 정책이 된다.

### 테스트는 정책이고 계약입니다

- 휴가로 부재중일 때 누군가 문서를 안 읽고 코드 변경 -> 테스트로 작성이 돼있었다면? -> 애초에 질문도 안들어 왔을 것
  - 유지하고 싶은 어떤 상태가 있다면, 전부 테스트로 작성해라


### Testablility

테스트 가능성. 소프트웨어가 테스트 가능한 구조인가?
- (너무 중요한 내용이라 이후에 다시)

### test double

- = 테스트 대역


<br>

## 2. 대역

  - dummy
    - 아무런 동작도 하지 않고, 그저 코드가 정상적으로 돌아가기 위해 전달하는 객체
  - fake
    - local에서 사용하거나 테스트에서 사용하기위해 만들어진 가짜 객체
    - 자체적인 로직이 있다는게 특징
      - eg. 테스트 중 어떤 내용을 기록한다
  - stub
    - 미리 준비된 값을 출력하는 객체
    - 주로 외부 연동하는 컴포넌트들에 많이 사용
    - 보통 mockito 프레임워크를 이용해서 구현된다.
  - spy
    - 모든 메서드 호출을 낱낱이 기록해두고 있는 객체
    - 메서드가 몇 번 호출됐는지, 잘 호출됐는지 검증
    - 이외에 다른 정보도 더 기록해서 검증에 사용하기도 함
  - mock
    - 메서드 호출을 확인하기 위한 객체
    - 자가 검증 능력을 갖춤
    - 사실상 test double과 동일한 의미로 사용 



<br>

## 인용

- Wikipedia contributors, "Behavior-driven development," Wikipedia, The Free Encyclopedia, https://en.wikipedia.org/w/index.php?title=Behavior-driven_development&oldid=1138005827 (accessed February 13, 2023).
- 타이터스 윈터스, 톰 맨쉬렉, 하이럼 라이트 큐레이션, 구글 엔지니어는 이렇게 일한다 구글러가 전하는 문화, 프로세스, 도구의 모든 것, 개앞맵시 역, (한빛미디어, 2022-05-10), 366p
- 마티아스 노박, 오브젝트 디자인 스타일 가이드 팀의 생산성을 높이는 고품질 객체지향 코드 작성법, 이상주 역, (위키북스, 2022), 28p
- 마티아스 노박, 오브젝트 디자인 스타일 가이드 팀의 생산성을 높이는 고품질 객체지향 코드 작성법, 이상주 역, (위키북스, 2022), 231p













<br><br>

# 의존성과 Testability(1)

## 1. 의존성

### 의존성이란?

> dependency(computer science) or coupling, a state in which one object uses a function of another object - Wikipedia

A는 B를 사용하기만 해도 A는 B에 의존한다고 할 수 있다.

사실 소프트웨어 공학에서 마하는 의존성 자체를 완전히 제거할 수는 없다. 의존성을 제거한다는 말은 객체 간의 협력을 부정하는 것, 또는 시스템 간의 협력을 부정하는 것이다. 그래서 대부분의 디자인 패턴(시스템)이나 설계는 어떻게 하면 의존성을 약화시킬 수 있는지를 고민한 결과물이다(의존성을 없애는 방향이 아니다).


### 의존성의 종류

의존성의 종류는 매우 다양하고 각 의존성마다 강도가 다르다.

- Wikipedia contributors, "Coupling (computer programming)," Wikipedia, The Free Encyclopedia, https://en.wikipedia.org/w/index.php?title=Coupling_(computer_programming)&oldid=1086406506 (accessed February 13, 2023).


### 의존성 역전

> dependency injection과 dependency inversion은 다르다.

- dependency injection은 의존성 주입(DI)  
- dependency inversion은 의존성 역전(SOLID-DIP)

### 의존성 역전이란?

> 첫 째, 상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.  
둘 째, 추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.

"(의존 관계를 나타내는)화살표의 방향을 바꾸는 테크닉"이라고 봐도 된다.

> 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다. 대신 세부사항이 정책에 의존해야 한다. - 로버트 C. 마틴, 클린 아키텍처 소프트웨어 구조와 설계의 원칙

> 자바와 같은 정적 타입 언어에서 이 말은 use, import, include 구문은 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다는 뜻이다. (중략) 우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰 구체적인 요소다. - 로버트 C. 마틴, 클린 아키텍처 소프트웨어 구조와 설계의 원칙

- 인터페이스나 추상 클래스 같은 추상적인 선언 -> 정책
- 변동성이 큰 구체적인 요소 -> 세부사항
















<br><br>

# 의존성과 Testability(2)

## 2. 의존성과 테스트

### 갑자기 의존성은 왜?

테스트를 잘 하려면 의존성 주입과 의존성 역전을 잘 다룰 수 있어야 한다.


### SOLID -> DIP: 의존성 역전 원칙

대부분의 소프트웨어 문제는 의존성 역전으로 해결이 가능하다.

...to be continued

<br>

## 3. Testability

...to be continued




<br>

## 인용

- Wikipedia contributors, "Dependency," Wikipedia, The Free Encyclopedia, https://en.wikipedia.org/w/index.php?title=Dependency&oldid=1090325642 (accessed January 23, 2023).
- Wikipedia contributors, "Coupling (computer programming)," Wikipedia, The Free Encyclopedia, https://en.wikipedia.org/w/index.php?title=Coupling_(computer_programming)&oldid=1086406506 (accessed February 13, 2023).
- 위키백과 기여자, "의존관계 역전 원칙," 위키백과, , https://ko.wikipedia.org/w/index.php?title=의존관계_역전_원칙&oldid=31527077 (2023년 1월 23일에 접근).
- 로버트 C. 마틴 저, 클린 아키텍처 소프트웨어 구조와 설계의 원칙, 송준이 옮김, (인사이트(insight), 2019-08-20), 65p
- 로버트 C. 마틴 저, 클린 아키텍처 소프트웨어 구조와 설계의 원칙, 송준이 옮김, (인사이트(insight), 2019-08-20), 92p











<br><br>

# 








<br><br>

# 




