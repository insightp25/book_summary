# 섹션3. 방향성 탐색

# 레이어드 아키텍처의 문제점과 해결책

## 한 줄 요약

> 레이어드 아키텍처의 문제를 의존성 역전을 활용해 해결한다.




<br>

## 1. H2

- H2를 사용하는 순간 그 테스트는 중형 테스트가 된다
- 테스트 한 번 돌리기가 부담
- 이것 자체가 뭔가 잘못됐다는 신호
  - 설계가 잘못되었을 확률
    - 시스템이 RDB에 강결합
  - 지금 작성한 테스트가 실제로 테스트가 필요한 본질이 아닐 확률
    - h2나 mockito 없이는 테스트가 불가
    - Elasticsearch 같이 테스트용 embedded 서버가 없는 DB는? -> 테스트 불가 -> 본질이 아닌 것
    




<br>

## 레이어드 아키텍처의 문제점

### 레이어드 아키텍처의 장점

- 쉽다. 가시적인 무언가를 만들기에 가장 쉬운 방법.

### 레이어드 아키텍처의 단점

1. (치명적)DB 위주의 설계를 유도한다. 모든 것이 영속성 계층을 토대로 만들어진다.
2. (치명적)동시 작업
  - repository -> service -> controller 순 구현 -> 특정 기능 개발은 한 명만 수행이 가능
  - 절차 지향적인 코드를 짰을 때 발생하는 문제이기도 하다.
3. 죽은 도메인
  - 계층형 아키텍처는 업무 도메인에 대해 아무것도 말해주지 않는다.
  - 객체에 대한 진지한 고민을 하지 않게 되며, 모든 객체는 getter setter를 갖고 수동적으로 돌아갈 확률 높아 + 모든 코드가 함수 위주로 돌아
  - 객체 지향이 아닌 절차 지향적 코드가 나오게 된다.
  - '사실상 service가 모든 일을 다 처리하는 신과 같은 존재가 된다'는 의미이기도(약칭 'fat service')
4. 동시 작업 불가
5. 규모가 커질수록 확장성이 떨어진다.

절차지향적 사고 유도 -> 낮은 testability + bad SOLID




<br>

## 개선된 아키텍처

- 도메인 레이어 추가 -> 서비스가 하던 역할을 도메인이 처리하도록 위임
  - 서비스는 레포지토리에서 도메인을 가져와서 도메인한테 일을 시키는 정도의 일만 하게 만듬
  - 도메인 레이어는 OOP스러운 객체들이 협력하는 그런 공간이 된다.
  - 도메인은 lombok 제외 어노테이션이 없는 오브젝트
  - 도메인은 계층간 연결된 의존성이 없음
    - 도메인 테스트시엔 계층간 의존성을 위해 mocking을 할 필요가 없어진다.
    - 그 자체로 순수 자바코드 -> 인스턴스화 쉬움 -> testability가 높아

- business(서비스) 레이어 -> 2개의 의존성(domain, repository)
  - 순수 java로 이루어져 있어 인스턴스화 어렵지 않아 -> 테스트 방해요인은 아냐

- persistence(eg. JpaRepository) 레이어 -> DB와 강결합 되어있는 JPA 코드를 인스턴스화 하는 것은 어려워
  - h2 같은 embedded DB 없이는 매우 어려워...어떻게든 해결해야.
    - 의존성으로 발생하는 문제는 대부분 `의존성 역전` 활용으로 해결 가능
  - 서비스 레이어에 Repository 인터페이스를 만들고 영속성 계층의 구현체에 이 인터페이스를 준다 + 구현체가 JPA 레포지토리 사용하도록 한다
    - 서비스 레이어는 영속성 계층과의 의존 관계가 놀랍도록 약해져(별 것 아닌 것 같아도 놀라운 발전)
    - 서비스에서 요구하는 구현은 Repository 구현체에서 알아서 한다 -> MySQL 등 RDB를 사용하다가 mongoDB로 갈아타더라도 서비스 코드는 전혀 영향을 받지 않게 해
- controller 레이어
  - 총 3개의 의존성: service, domain, repository -> 마찬가지로 `의존성 역전` 활용






<br><br><br><br><br>

---

# 어떻게 변경할 것인가?

## 테스트의 범위

클린 아키텍처 'humble' 개념 참고

Q. controller랑 repository 구현체를 테스트하지 않으면 커버리지가 낮아질 텐데?

"도메인이야말로 애플리케이션의 핵심이다"

애플리케이션은 service와 domain이 핵심  
이 두 부분이 잘 만들어져 있어야 애플리케이션의 내적 품질이 향상, 이곳 테스트가 전체 애플리케이션 테스트를 위한 '최소 조건'  



<br>

## 낮은 커버리지 걱정

- 걱정: JPA, Spring 쪽 테스트 안하면 커버리지가 너무 낮게 나온다
- 도메인: 도메인이 그만큼 빈약하다는 의미
- 경쟁력: 서비스의 경쟁력을 의심해봐야

서비스가 CRUD를 제외하면 도메인이랄 게 없단 의미 -> 지금 만드는 서비스가 "조금 규모가 큰 'TODO 앱'을 만들고 있을 뿐"이란 것 -> 그런 애플리케이션에 테스트가 꼭 필요할까?

## 실기전 주의사항

의존성 역전 원리 이용해 외부를 다룸  
의존성 역전은 '의존 관계를 약화시킨다', '호출자와 구현체를 독립적으로 구성하겠다'는 의미

- 의존성 역전: 의존 관계를 약화시킨다
- 독립: independent of X
- 테스트 가능성: testable

## 실기전 추가 내용

리팩토링 a. 패키지 관리 + 의존성 역전  
리팩토링 b. 패키지 의존성: 순환 참조가 생기는지 의식하며 개발해야.  
리팩토링 c. JPA 엔티티와 도메인 모델을 분리  
리팩토링 d. setter를 없애고 domain/vo로 로직 이동  
리팩토링 e. CQRS(command and query responsibility segregation): 명령과 질의의 책임 분리. 메소드를 명령과 질의로 나누자(더 넓게는 클래스까지).  

### CQRS 관련

- 명령(command): 상태를 바꾸는 메소드
  - 명령 메소드는 void 타입이어야.
  - 편의상 명령 메소드가 종종 return this 하는 경우도 있는데, 이렇게 되어도 안돼.
- 질의(query): 상태를 물어보는 메소드
  - 질의 메소드는 상태를 변경해서는 안돼.

"하나의 메소드는 명령이나 쿼리여야하며, 두 가지 기능을 모두 가져서는 안된다. 명령은 객체의 상태를 변경할 수 있지만, 값을 반환하지 않는다. 쿼리는 값을 반환하지만 객체를 변경하지 않는다." - 마이클 C. 페더스, 레거시 코드 활용 전략 - 손대기 두려운 낡은 코드, 안전한 변경과 테스트 기법

Repository 대신 Reader/Writer로 구분, Readonly 객체와 Editable 객체로 분리.



