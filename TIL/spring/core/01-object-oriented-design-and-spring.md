# section1. 객체 지향 설계와 스프링
(빠르게 review하고 핵심만 기록하는 용도, 축약 및 생략 다수)

# 스프링이란?

## 스프링 프레임워크
* 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, etc...
* 웹 기술: 스프링 MVC, 스프링 WebFlux
* 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원
* 기술 통합: 캐시, 이메일, 원격접근, 스케줄링
* 테스트: 스프링 기반 테스트
* 언어: Java, Kotlin, Groovy

## 스프링 부트
* 단독 실행 가능 스프링 애플리케이션 생성
* Tomcat 등 웹 서버 내장, 웹 서버 설치 불필요
* ...

## 스프링은 왜 만들었는가?
* 일반적 답변
  * 1단어: 객체 지향
  * 1줄: 좋은 객체 지향 애플리케이션을 개발할 수 있게 하기 위해
  * (+1줄 추가: 자바 등 객체 지향 언어가 가진 강력한 특징을 살려내고)
* 구체적 답변
  * 1단어: `설정자`
  * 1줄: `다형성만으론 OCP, DIP 원칙을 지킬 수 없으므로, 별도 설정자를 제공`
  * (+1줄 추가: DI, IoC로 다형성을 보조해 SOLID를 준수하는 객체 지향 프로그램을 개발할 수 있게 하기 위해)

<br>

---
# 좋은 객체 지향 프로그래밍이란?

## 객체 지향 프로그래밍
* 협력
  * 프로그램을 명령어의 목록으로 보는 시각에서 벗어나,
  * 여러 개의 독립된 '객체'라는 단위들의 모임으로 파악하고자 하는 것.
  * 각각 객체는 메시지, 데이터를 주고받고 처리한다.
* `유연, 변경 용이`
  * 대규모 소프트웨어 개발에 많이 사용 가능

## 유연, 변경 용이?
* 레고 블럭을 갈아 끼우듯이 컴포넌트를 쉽고 유연히 변경하면서 개발 가능

## 다형성
* `역할`과 `구현`으로 세상 구분
  * 예1:
    * 역할: 자동차
    * 구현: K3, 아반떼, 테슬라 모델3
    * (운전자는 자동차 역할(운전)만 숙지하면 모든 구현을 구동할 수 있다)
  * 예2:
    * 로미오 역할-장동건/원빈 구현, 줄리엣 역할-김태희/송혜교 구현
  * 역할 = 인터페이스, 구현 = 인터페이스를 구현한 객체

## 객체의 협력이라는 관계부터 생각
* 혼자 있는 객체는 없다
* 수 많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 갖는다.

## 자바 언어의 다형성
* 오버라이딩

## 다형성의 본질
* `클라이언트`를 변경하지 않고-`서버` 구현 기능을 유연히 변경할 수 있다.
  * (서버-클라이언트 등 객체간 `협력`에서 시작해야 이해 가능)
* 확장 가능 설계, 클라이언트에 영향 주지 않는 변경, 인터페이스 설계 중요

## 스프링과 객체 지향
* 다형성이 가장 중요!
* 스프링은 다형성을 극대화 - 제어 역전(IoC), 의존관계 주입(DI)

<br>

---
# 좋은 객체 지향 설계의 5가지 원칙(SOLID)
## SRP: 한 클래스는 하나의 책임만 가져야 한다
  * 하나의 책임은 모호. 클 수도, 작을 수도. 문맥, 상황에 따라 달라.
  * 중요한 기준은 `변경`. 변경시 파급 효과가 적으면 단일 책임 원칙 잘 따른 것.
## OCP: 확장에 열려 있으나 변경에 닫혀 있어야 한다
  * 다형성을 활용하자
  * eg. 인터페이스(역할)를 구현한 새로운 클래스 하나 만들어(확장) 새로운 기능 구현 -> 역할 변경은 없으나, 기능이 확장되었다.
  * 구현체 갈아 끼울 때 클라이언트 코드 변경 없인 불가, OCP 원칙 적용 불가 -> 별도 조립, 설정자 필요 -> DI, IoC
## LSP: 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다
  * 다형성에서 하위 클래스는 인터페이스 `규약`을 다 지켜야 한다는 것.
  * `단순히 컴파일 성공을 넘어서는 이야기`
  * eg. 자동차 인터페이스의 엑셀 기능은 앞으로 가는 것 -> 뒤로 가게 구현시 LSP 위반(컴파일은 된다). 느리더라도 앞으로 가야.
## ISP: 특정 클라이언트 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
  * eg. 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
    * 분리시 정비 인터페이스가 변해도 운전 인터페이스를 사용하는 클라이언트에 영향이 없다
  * (인터페이스가 명확해지고, 대체 가능성이 높아진다)
## DIP: 추상화에 의존해야지, 구체화에 의존하지 말라
  * 역할(인터페이스)에 의존해야 한다는 것과 같음
  * eg. repository 구현체 생성을 service 구현체(클라이언트) 코드에서 직접 해버린다 -> DIP 위반

## 정리
* 객체 지향 핵심은 다형성
* 다형성 만으로는 OCP, DIP 지킬 수 없다

<br>

---

# 전체 정리
* 모든 설계에 역할 구현 분리
* 이상적으로는 모든 설계에 인터페이스 부여

## 실무 고민
* 인터페이스 도입시 추상화 비용 발생
* `기능을 확장할 가능성이 없다면`, 구체 클래스를 직접 사용하고, 향후 꼭 필요시 리팩토링해 인터페이스 도입하는 것도 방법이다.