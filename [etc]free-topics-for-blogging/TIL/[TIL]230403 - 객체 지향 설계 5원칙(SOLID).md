
# 객체지향 설계 5원칙
> 객체지향 설계 5원칙(SOLID): 응집도는 높이고(high cohesion), 결합도는 낮추라(loose coupling)는 고전 원칙을 객체 지향의 관점에서 재정립한 것. SOLID는 디자인 패턴의 뼈대이자 스프링 프레임워크의 근간이라고 볼 수 있다.

#### SOLID 개요
SOLID는 아래 5가지 원칙의 앞 머리 알파벳을 따서 부르는 이름이다.
- SRP(Single Responsibility Principle): 단일 책임 원칙
- OCP(Open Closed Principle): 개방 폐쇄 원칙
- LSP(Liskov Substitution Principle): 리스코프 치환 원칙
- ISP(Interface Segregation Principle): 인터페이스 분리 원칙
- DIP(Dependency Inversion Principle): 의존 역전 원칙

SOLID는 객체 지향 프로그램을 구성하는 속성, 메서드, 클래스, 객체, 패키지, 모듈, 라이브러리, 프레임워크, 아키텍처 등 다양한 곳에 다양하게 적용된다.

#### 결합도
모듈(클래스)간 상호 의존 정도. 결합도가 낮으면 모듈 간 상호 의존성이 줄어 객체의 재사용, 수정, 유지보수가 용이해진다.
- 결합도 수준: 데이터 결합도, 스탬프 결합도, 컨트롤 결합도, 외부 결합도, 공유 결합도, 내용 결합도

#### 응집도
하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성. 응집도가 높으면 모듈은 하나의 책임에 집중하고 독립성이 높아져 객체의 재사용, 수정, 유지보수가 용이해진다.
- 응집도 수준: 기능 응집도, 통신 응집도, 절차 응집도, 시간 응집도, 논리 응집도, 우연 응집도


</br>

## SRP - 단일 책임 원칙

> "어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다."

- 클래스를 역할과 책임에 따라 분리해 각각 하나의 역할과 책임만 갖도록 해야한다는 원칙
- 객체 지향 4대 특성 중 SRP와 가장 관계가 깊은 것은 모델링 과정을 담당하는 추상화이다. 애플리케이션의 경계를 정하고 추상화를 통해 클래스들을 선별하고 속성과 메서드를 설계할 때 SRP의 고려가 반드시 필요하다.

#### SRP의 확장
- 클래스 외에도 속성, 메서드, 패키지, 모듈, 컴포넌트, 프레임워크 등에도 적용할 수 있다.
- 데이터베이스 테이블을 설계할 때 정규화라는 과정을 거치는데, 이 과정을 확장해서 생각해보면 테이블과 필드에 대한 SRP의 적용이라고 할 수 있다.
- (속성, 메서드 등이 SRP를 지키지 않을 경우 나타나는 대표적인 사례에 if문 분기 처리가 있고, if문이 남발되는 경우 SRP에 위배되지 않는지 생각해볼 수 있다)
</br>

## OCP - 개방 폐쇄 원칙

> "소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다."

- "자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다."
- 좋은 사례들
  - JDBC: 자바 애플리케이션은 JDBC 인터페이스로 인해 데이터베이스가 오라클, MySQL, MS-SQL 등 무엇으로 바뀌더라도 변화에 영향을 받지 않는다.
    - 자바 애플리케이션은 데이터베이스라는 주변의 변화에 닫혀있는 것이고, 데이터베이스를 교체한다는 것은 데이터베이스가 자신의 확장에는 열려 있다는 것이다.
  - 자바: 자바에도 OCP가 적용돼 있다고 볼 수 있다. JVM이라는 완충 장치로 변화에 영향을 받지 않기 때문. 자바 개발자는 소스코드가 윈도우에서 구동될지, 리눅스에서 구동될지 걱정하지 않아도 된다.

</br>

## LSP - 리스코프 치환 원칙

> "서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있다."

- 하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류다.
- 구현 클래스 is able to 인터페이스 - 구현 분류는 '인터페이스할 수 있어야(Cloneable, Runnable...etc.)' 한다.
- "객체 지향에서의 상속은 조직도나 계층도가 아닌 분류도가 돼야 한다"
- "하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다"
```java
  // LSP 위배: 상위 클래스 아버지-하위 클래스 딸 구조(계층도/조직도). 춘향이가 아버지의 어떤 역할을 할 수 있을까?
아버지 춘향이 = new 딸();

// LSP 만족: 동물-펭귄 구조(분류도)
동물 뽀로로 = new 펭귄();
```

- 하위형에서 선행 조건은 강화될 수 없다.
- 하위형에서 후행 조건은 약화될 수 없다.
- 하위형에서 상위형의 불변 조건은 반드시 유지돼야 한다.

</br>


## ISP - 인터페이스 분리 원칙

> "클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다"

- SRP와 ISP는 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있다.
  - 한 클래스가 다수의 역할을 맡고 있다면:
    - SRP: 역할 별 클래스를 분할, 구분
    - ISP: 역할 별 인터페이스로 분할, 구분
  - (하지만 특별한 경우가 아니라면 SRP 적용이 더 좋은 해결책이다)
- 인터페이스 최소주의 원칙
  - 인터페이스 외부 제공 시 최소한의 메서드만 제공
  - "상위 클래스는 풍성할 수록 좋고, 인터페이스는 작을 수록 좋다"
  - 장점
    - 같은 객체라도 상황에 따른 분명한 역할 구분이 가능하다(eg. 한 사람은 공적인 일도 하고 사적인 일도 하지만, 때와 장소에 따라 구분하여 행동할 수 있다. 즉, 공적인 장소에서 사적인 일을 하지 않고 공적인 일만 수행할 수 있다.)
- (그 외: 인터페이스는 "~할 수 있는is able to"라는 기준으로 만드는 것이 정석임을 기억하자)

</br>

## DIP - 의존 역전 원칙

> "고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다."
"추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다."
"자주 변경되는 구체(concrete) 클래스에 의존하지 마라."

- "자신보다 변하기 쉬운 것에 의존하지 마라"
  - 상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높다.
  
</br>

</br>

# 그 외에 관련하여...

## SoC - 관심사의 분리
- "하나의 속성, 하나의 메서드, 하나의 클래스, 하나의 모듈, 하나의 패키지에는 하나의 관심사만 들어 있어야 한다"
- "관심이 같은 것끼리는 하나의 객체 안으로, 혹은 친한 객체로 모으고, 관심이 다른 것은 가능한 한 따로 떨어져 서로 영향을 주지 않도록 분리하라"
- SoC(Separation of Concerns)를 적용하다보면 자연스럽게 SRP, ISP, OCP에 도달하게 된다. Spring도 SoC를 통해 극한까지 SOLID를 적용하고 있다.
</br>

## 객체 지향의 의미와 SOLID
- 객체 지향은 현실 세계를 모델링하는데 이는 다음을 의미한다.
  1. 객체 지향 세계는 현실 세계 같아야 한다.
  2. 모델링을 통한 추상화
- SOLID는 첫 번째보다 두 번째 요건에 초점을 맞추고 있다.

</br>

</br>

# reference
- 스프링 입문을 위한 자바 객체 지향의 원리와 이해. 김종민. 2015. 위키북스.