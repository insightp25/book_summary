# 암호화란?

## 암호화encryption
- 평문(plaintext)을 암호문(ciphertext)으로 변환하는 것
  - 평문: 누구나 읽으면 곧바로 이해할 수 있는 정보
  - 암호문: 읽는다고 모두가 이해할 수는 없는 정보
- 암호문도 누군가 훔쳐볼 수 있음
- 단, ***특별한 정보***를 아는 사람만 이해할 수 있음

## 복호화decryption
- 암호문을 다시 평문으로 변환하는 것
- ***암호화에 사용한 방법***을 알아야 빨리 복호화 가능

## 해시 알고리즘과의 차이점
- 해시 알고리즘은 원문 복구를 막는 게 목표 :복호화 불가. one-way function.
- 암호화 알고리즘은 원문 복구를 허용해야 함

원문 복구가 필요하다면 암호화를 하는 게 맞다.




<br>

# 암호화의 역사
- 고대 이집트 시절 무덤에서 부터 고대 그리스 로마군, 19~20세기까지. 특히 군용으로 많이 사용.
- 2차 세계 대전 중 독일군이 사용한 에니그마 기계도 글자 교환 방식.
  - 단, 매일 글자 목록이 바뀜
  - 이 규칙을 미리 알고 있지 않으면 24시간마다 규칙을 찾아내야 함

## 현대 사회의 암호화
- 평화시대일 수록 모든 것을 암호화해야 함
- 이유1: 전화/온라인 통해 타인과 대화하는 일 증가
  - 둘 사이 대화 가로챌 수 있음
- 이유2: 온라인에 저장된 정보가 너무 많음(특히 개인정보)
  - 이젠 거의 모든 정보가 디지털화
  - 그중 대다수가 온라인에 저장
  - 서버가 털리면 타겟이 아닌 사용자도 함께 털림 :나를 타겟으로 삼지 않아도 내가 범죄의 피해자가 될 수 있음

이 모두는 컴퓨터 때문에 생긴 일. 온라인화, 디지털화의 새로운 시대에 맞는 새로운 방법 필요.

- (컴퓨터 성능 향상으로 인해)이전 시대의 글자 교환 방식은 현재 무차별 대입 공격으로 매우 쉽게 깨지는 방법 
- 현재 컴퓨터 성능으로 사실상 깰 수 없는 암호화 기법 필요(이것도 언젠가 깨짐 주의)





<br>

# 정수론*number theory*

- 정수의 성질에 대해 연구하는 학문
- 과거엔 실용적으로 사용할 곳이 거의 없어 경시
- 2진수 표현 데이터를 암호화하려다 보니 갑자기 급부상
  - 결국 2진수도 정수
- 특히 소수 관련 정수론적 알고리즘에 많은 주목
  - 암호문 패턴을 들키지 않으려면 겹치지 않는 수 필요
  - 소수는 자연에서 가장 안 겹치는 수

## 암호학에서 사용하는 정수
- 매우 큰 정수
  - 흔히 사용하는 32비트 등의 정수가 아님
  - 32비트 범위 안에 있는 소수는 오직 203,280,220개 뿐
- 입력 크기 N
  - 보통 배열 속 요소 수 의미
  - 암호학에서 사용하는 정수에서는 비트 수 의미
- 곱셈, 나눗셈, 나머지 연산의 시간 복잡도
  - 보통 정수는 O(1)
  - 암호학에서 사용하는 정수는 비트 수에 비례

## 현대에 사용하는 암호화 알고리즘 두 종류

1. 대칭 키 암호화*symmetric-key encryption)
  - 암호화/복호화에 동일한 키 사용
2. 비대칭 키 암호화*asymmetric-key encryption)
  - 공개 키 암호화(public-key encryption)라고도 함
  - 암호화와 복호화에 사용하는 키가 상이






<br>

# 대칭 키 암호화

- 암호화/복호화 동일한 키 사용
- 이 키는 메시지 송신자와 수신자가 공유하는 비밀
  - 수신자가 이미 그 키를 가지고 있어야 복호화 가능
- 송신자가 수신자에게 비밀스럽게 키를 알려줄 방법 필요
  - 다른 사람들은 몰라야 비밀 유지 가능
  - 대칭 키 암호화의 가장 큰 단점

eg. string 평문을 8비트 아스키로 2진수화 한 후 8비트 암호화 키로 XOR 연산(XOR 연산을 두 번 실행하면 원문으로 복귀)

## 스트림 암호 vs. 블록 암호

- 방금 예는 스트림 암호(stream cipher)의 예
  - 한 번에 1바이트씩 받아 암호화를 진행
  - 안전하려면 각 바이트에 적용하는 키가 달라야 함
    - 보통 시드(seed) 값을 정하고 난수로 생성
  - 블록 암호보다 설정이 복잡하나 속도가 빠름

- 블록 암호(block cipher)
  - 정해진 블록 크기(64비트 이상) 만큼의 바이트를 한 번에 암호화
  - 각 블록에 사용하는 키 동일
  - 스트림 암호보다 설정이 간단하나 속도가 느림

효과는 둘 다 좋음





<br>

## Wi-Fi 비밀번호도 일종의 대칭 키

- 카페 갈 때마다 받는 Wi-Fi 비밀번호도 일종의 대칭 키
  - 공유기에 설정하는 비밀번호와 스마트폰에 입력하는 키가 같음
  - 스마트폰과 공유기 사이에 통신할 때 이 키로 암호화
- 따라서 그 키를 아는 사람만 메시지를 해독할 수 있음

그럼 카페에 있는 사람이 모두가 내 메시지를 볼 수 있는 건가? -> No. WPA2-Personal 사용.

- WPA2-Personal은 이런 식으로 작동
  - 스마트폰이 처음 공유기에 접속시 교환하는 어떤 값과 비밀번호를 합쳐 키 생성
  - 그 키를 이용해 메시지 암호화
  - 따라서 모든 접속자마다 다른 키 사용
  - 하지만 해커가 둘 사이의 모든 트래픽을 캡처한다면 읽기 가능






<br>

# AES 알고리즘의 구성

대칭키 알고리즘 목록: DES, IDEA, Blowfish, AES, RC4, RC5, RC6 등...

가장 유명한 대칭 키 알고리즘을 하나 보자.

## AES(Advanced Encryption Standard)

- NSA에서 일급비밀용으로 승인한 유일한 공개 암호화 알고리즘
- 현재 가장 널리 사용되는 대칭키 알고리즘
  - 앞에서 든 WPA2 프로토콜의 일부로 사용되기도 함
- 블록 크기: 128비트
- 키 길이: 128, 192, 또는 256 비트
- 키 길이에 따라 평문을 암호문으로 변환하는 라운드 수가 다름
  - 128비트: 10라운드
  - 192비트: 12라운드
  - 256비트: 14라운드
- AES는 한 번에 16바이트씩 읽어서 암호화
- 16바이트를 4 x 4 행렬로 배치(eg. [[b0, b4, b8, b12], ...[..., b15]])
- 그 뒤 여러 처리 과정을 통해 암호화 진행

1. 키 확장
2. 0 라운드
  1. 라운드 키 더하기
3. 9/11/13 라운드
  1. 바이트 대체
  2. 행 이동
  3. 열 섞기
  4. 라운드 키 더하기
4. 최종 라운드(총 라운드 수가 10/12/14가 됨)
  1. 바이트 대체
  2. 행 이동
  3. 라운드 키 더하기

128비트 평문 -> 0라운드 알고리즘 연산 + 키0 -> 1라운드 알고리즘 연산 + 키1 -> ... 최종라운드 알고리즘 연산 + 키R -> 128비트 암호문







<br>

# AES의 내부 연산1

## 1. 키 확장(key expansion)

- 대칭키로부터 각 라운드에 사용할 여러 키 생성
  - 이를 라운드 키라고 부름
  - 생성법이 궁금하면 AES key schedule을 검색해 볼 것
- 총 라운드 수 + 1개의 라운드 키를 만듬(0 라운드부터 시작 -> +1개)
  - 즉, 각 라운드마다 다른 키 사용
- 대칭키의 길이는 128/192/256 비트 중 하나
- 그로부터 생성한 라운드키는 모두 128비트



<br>

## 2.a) 0 라운드 - 라운드 키 더하기
- 0 라운드 키를 원문에 더함(AddRoundKey)
- 더한다는 의미는 배타합(xor)
- 송신자/수신자만 알 수 있는 키로 원본 메시지 숨기기

각 라운드의 output이 다음 라운드의 input이 된다.



<br>

## 3.a) 여러 라운드 - 바이트 대체

- 각 바이트를 다른 바이트로 대체함(SubBytes)
  - AES S-Box라는 룩업 테이블 사용
- 선형적 변환이 아니라 단순 사칙 또는 비트 연산으로 찾을 수 없음!
  - 혼돈*confusion* 효과 성취




<br>

## 3.b) 여러 라운드 - 행 이동

- 4개의 행을 각각 다르게 왼쪽으로 이동(ShiftRows. bit shift/bit rotation과 비슷. 단, 바이트단위로.)
  - 1행: 이동 없음
  - 2행: 1 만큼
  - 3행: 2 만큼
  - 4행: 3 만큼
- 확산(diffusion) 효과 성취




<br>

# AES의 내부 연산1

## 3.c) 여러 라운드 - 열 섞기

- 각 열에 있는 4바이트를 선형적으로 변환(MixColumns)
  - 행렬 x 벡터 곱을 이용(따라서 결과도 4바이트)
    - 단, 일반 곱셈이 아니라 갈루아 필드 GF(2^8)에서의 곱
- 행 이동과 마찬가지로 확산(diffuse) 효과 성취

행렬 x 벡터 곱에서 덧셈은 배타합(xor), 곱셈은 특별한 규칙 따름.





<br>

### (교양)열 섞기 단계의 곱셈 규칙 - 1로 곱할 때
- 일반적 곱셈과 동일
- 원래 값 그대로 유지

eg. CD * 1 = CD

### (교양)열 섞기 단계의 곱셈 규칙 - 2로 곱할 때
1. 원래 값에 2를 곱함(=왼쪽으로 1만큼 비트 시프트)
2. 원래 값의 최고 비트가 1이었다면 0x1B로 xor

### (교양)열 섞기 단계의 곱셈 규칙 - 3으로 곱할 때
- 일반 산술연산: x * 3 = x * 2 + x
- 여기서도 위 규칙 따름: x * 3 = x * 2 +(배타합) x
  1. 방금 전 봤던 2로 곱하는 규칙 적용
  2. 그 결과에 원래 값을 xor 한다.




<br>

## 3.d) 여러 라운드 - 라운드 키 더하기

- 라운드 키를 더함(AddRoundKey)
- 그리고 3.a) ~ 3.d) 단계를 여러 번 반복
  - 대칭키가 128비트면 9라운드
  - 대칭키가 192비트면 11라운드
  - 대칭키가 256비트면 13라운드
- 다음 라운드의 시작점은 이번 라운드의 결과값!





<br>

## 4. 최종 라운드

1. 바이트 대체
2. 행 이동
3. 라운드 키 더하기
  - 열 섞기만 안 함
  - 그 결과가 최종 암호문






<br>

# 코드보기: AES

- AES는 Java에서 기본적으로 지원하는 기능
- `Cipher` 객체는 암호화를 하는 객체. "AES/CBC/PKCS5Padding"는 CBC 블록 암호 운용 방식(block cipher mode)과 PKCS5 패딩 방식으로 AES 암호화 알고리즘을 사용한다는 의미.
- 블록 암호 운용 방식과 패딩이 무엇인지는 자세한 설명 생략. 간단하게 말하면 AES는 블록 암호이기 때문에 특정한 길이의 블록 단위로 암호화. 때문에 가변 길이의 데이터는 암호화할 때 블록 단위로 나누고 그 블록들을 어떻게 암호화하는지 정해야 함. 그것이 블록 암호 운용 방식.
- ECB나 CBC와 같은 여러 모드가 존재.


- 구현
  - `encrypt()` 메서드 구현
  - AES는 128, 192, 256 비트의 키만 허용하기 때문에 여기서 `assert()`로 확인해줌
  - key와 메시지를 byte 배열로 바꿈
  - key를 사용해 `SecretKeySpec` 객체를 만듬. 이 객체는 `Cipher` 객체를 만드는 데 사용됨.
  - Padding은 plaintext의 크기가 블록 크기(128비트)의 배수가 아닌 경우에 사용. 그럴 때는 블록 크기의 배수가 되도록 패딩.
  - `SecretKeySpec` 객체와 초기화 벡터(IV)를 사용해 암호화 모드로 cipher 객체 초기화.
    - IV는 의미론적 안전성(semantic security)을 위해 암호문에 무작위성을 추가하는 랜덤 데이터. 여기서 IV는 상수이지만 실제 프로그램에서는 이 값을 랜덤하게 만들어야 함.
  - 마지막으로 plaintext를 다음과 같이 암호화...
  - 그리고 base64로 인코딩 된 암호문을 반환
  - 복호화 하려면 암호화를 했던 것과 반대로 해야 함
  - `cipherText`를 base64에서 디코딩
  - `cipher`의 복호화 모드를 사용. 또한 암호화에서 사용했던 IV를 그대로 사용해야 함.
  - `plaintext`로 복호화하고 문자열로 반환
  - plaintext들을 AES128, AES192, AES256을 사용해 복호화
  - `ciphertext`와 `longCiphertext`의 길이가 다른 점 주목
  - 각 base64 숫자는 정확히 6비트이므로, 128/6 = 21.3333 -> 22 문자가 됨.
  - `==`는 base64 인코딩이 추가한 패딩이기 때문에 길이에 포함하지 않았음
  ...




<br>

# 비대칭 키 암호화

## 대칭키 암호화의 문제
- 대칭키 암호화는 훌륭한 기법이며 쓸 곳도 많다
  - 하드디스크에 파일을 암호화하여 저장
  - 데이터베이스에 고객 정보 저장
  - 사내 서버간 통신 암호화
- 하지만 암호화/복호화에 동일한 키를 사용해서 가끔 발목이 잡힘
  - 메시지 교환용으로 사용할때 안전하게 키 배포가 힘듬
  - 앞의 Wi-Fi 접속 사례
- 보안 문제없이 쉽게 키를 배포할 수 있는 방법이 필요




<br>

## 가장 쉽게 키를 배포하는 법
- 복호화에 사용할 키를 완전히 공개
- 그러면 누구나 쉽게 그 키를 획득(eg. 다운로드)할 수 있음
- 수학 신의 힘을 빌림(비대칭키 암호화)




<br>

## 비대칭키 암호화
- 암호화와 복호화에 사용하는 키가 다름
- 두 키 사이에는 특수한 수학적인 관계가 있음
  - 둘 중 한 키로 암호화한 메시지를 다른 키로 복호화할 수 있음
- 따라서 키 하나는 완전히 공개해도 상관없음
  - 이 키를 공개 키(public key)라고 부름
  - 비대칭키 암호화를 공개키 암호화라고도 부르는 이유도 이것 때문
- 다른 키 하나는 한 개인이 비밀로 가지고 있음
  - 이 키를 비밀키 또는 개인키(private key)라고 부름

공개 키와 비밀 키 사이에는 수학적인 관계가 있다.




<br>

## 올바른 메시지 암호화
- 송신자가 수신자의 공개키로 원문 -> 암호문 변환
  - 키가 공개돼 있으니 누구나 암호화 가능
  - 공개키로는 암호문 -> 원문 변환 불가
- 수신자는 자신의 비밀키로 암호문 -> 원문 변환
  - 수신자만 알고있는 키
  - 수신자만 원문을 볼 수 있음


<br>

# 비대칭키 암호화의 두 가지 주요 용도

1. 전송하는 메시지의 암호화
  - 다른 사람이 원문을 못 보게 숨김
2. 전자서명(digital signature)
  - 메시지는 누구든 볼 수 있음
  - 메시지 송신자가 올바름을 증명
  - 암호화폐에서 돈을 옮길 때도 이 방법 사용
    - 로그인 시스템이 없기 때문




<br>

# RSA와 큰 소수

## 비대칭키 암호화를 사용하는 곳

- https
  - 비대칭키 암호화와 더불어 대칭키 암호화도 사용
  - http는 평문이 왔다갔다 함. https는 비대칭 키 암호화를 사용해 내가 보내는 전송 모두 암호화.
- 메신저 앱의 비밀채팅 모드
  - 서버도 내 비밀키를 모르는 모드
  - 내 비밀키, 받는 사람의 공개키로 통신
  - 서버는 암호화된 암호문만 저장, 서버에서 풀 방법이 없다.
- 비트코인 등의 암호화폐 프로토콜
- Git 커밋의 전자서명
  - 예: GitHub에서 지원하는 GPG 키(퍼블릭 키 저장해두는 것)
  - 커밋할 때 내 비밀 키로 전자서명 하고 업로드하면, 깃허브에서 내 로그인시스템에 저장돼있는 공개 키랑 비교해 전자서명이 맞는지 확인해준다.

## 대표적 비대칭 키 암호화 기법
- Diffie-Helmal key exchange
- RSA(Rivest-Shamir-Adleman)
- 디지털 서명 알고리즘(Digital Signature Algorithm, DSA)
- 타원곡선 DSA(Eliptic Curve DSA, ECDSA)

## RSA
- 현재 데이터 전송용으로 매우 널리 쓰이는 암호화 기법
- 정수론에 기초해 놀라운 일들 성취
- 공개 키/비밀 키 쌍을 만드는게 매우 쉬움
  - 매우 큰 두 소수(prime number) 이용
- 이 두 키는 특수한 수학적 관계를 가짐
  - 공개 키를 알아도 그로부터 비밀 키를 찾기 매우 어려움
  - 거듭제곱과 나머지 연산만으로 암호화 가능
  - 암호문을 다시 거듭제곱한 뒤, 나머지 연산을 하면 원문이 돌아옴

## 사랑스러운(?) 소수의 특징
- 소수는 더 이상 인수분해가 안 되는 숫자
  - 1과 소수 그 자체로만 나눠짐
- 서로 다른 두 소수 p, q를 곱하면 합성수(소수가 아닌, 소수 여러 개를 합쳐서 만든 수) n이 나옴
- n의 인수는 p와 q 뿐


## RSA가 이용하는 소수의 성질
- 두 소수를 곱하는 것은 누구나 쉽게 할 수 있는 연산
  - 예: 22,637 * 58,391 = 1,321,797,067
- 두 소수를 곱한 합성수에서 그 소수들을 찾는 것은 훨씬 어려움
  - 이렇다 할 알고리즘이 없어 모든 조합을 곱해봐야 함
  - 예: "8,240,089,769를 인수분해 하시오"(10자리 수)
    - 대략 곱셈을 sqrt(8,240,089,769) -> 90,775번 정도 해야 함

## 200 짜리 숫자에서 두 소수 찾기
- 시도해야 하는 곱셈 수는 sqrt(10^200) = 10^100 정도
- 컴퓨터가 1초에 곱셈을 100만 번 할 수 있다면 10^100/10^6 = 10^94초 소요
  - 참고로 우주 나이 10^18초 정도
  - 그러면 우주 나이보다 10^76배 시간 필요하단 뜻


<br>

# RSA 키 길이와 연산 속도
- NIST에서 권하는 RSA의 키 길이
  - 2002년: 1024비트
  - 2015년: 2048비트
- RSA-2048은 1024 비트 소수를 2개 사용
  - 2^1024 = 1.798 * 10^308
  - 즉, 308자리 숫자
- 혹시라도 컴퓨터 속도가 더 빨라지면 비트 수를 늘리면 됨
  - 이미 4096 비트를 사용하는 사람도 있음(1.04 * 10^1234)

## RSA 공개 키/비밀 키의 기초
- "비밀 키": 아주 큰 소수 p, q
- "공개 키": 합성수 n(n = p * q)
- p, q를 모르면 n으로부터 p, q를 찾기 매우 어려움
  - 즉, 공개 키로부터 비밀 키를 찾기가 매우 어려움
  - 이것이 RSA 공개 키/비밀 키 간의 첫 번째 특수한 관계

## 공개 키/비밀 키의 두 번째 특수한 관계
- p, q와 특수한, 그리고 서로 간에도 특수한 관계인 e와 d를 찾음
  - e: 공개 키의 두 번째 요소가 됨
  - d: 비밀 키의 두 번째 요소가 됨
- e와 d는 다음의 관계를 만족해야 함

`(m^e)^d === m(mod n)`

`de === 1(mod λ(n))` (de 곱한 다음 카마이클수(λ(n))로 나누면 나머지가 1이어야 한다)

(`===`는 '동치'의 뜻. 합동식.)

n: 두 소수 p와 q를 곱한 값

m: 원문(plaintext)

---

### (교양)합동식(modular congruence)

`a === b(mod n), 1 < n`

- mod n이 좌항/우항에 모두 적용(a = b % n과 다름)
- 여러 가지 방식으로 이해 가능

1. a - b = kn (k: 어떤 정수)
  - a - b는 n의 배수
2. a % n = b % n
  - a를 n으로 나눈 나머지와 b를 n으로 나눈 나머지가 같음





<br>

# RSA 키 생성

## RSA 키 생성

1. 매우 큰 두 소수 p와 q를 찾는다
2. p와 q를 곱해 n을 만든다
3. p, q와 특수한 수학적 관계인 e를 찾는다
4. e와 특수한 수학적 관계인 d를 찾는다


### 1. 매우 큰 두 소수 p와 q를 찾는다

1. 매우 큰 랜덤 수를 뽑는다
2. 그 수가 소수인지 판별한다
  - 확률적 알고리즘을 통해 꽤 빠르게 할 수 있음(예: 밀러-라빈 소수 판별법)
    - 확률적 알고리즘은 몇 회차를 돌리면 틀릴 확률이 너무너무 작아진다 -> 모두 나눠보지 않고 소수라고 가정하고 진행
3. 소수가 아니라고 판별되면 1번 단계로 돌아간다
4. 서로 다른 두 소수(소수일 확률이 매우매우 높은 수)를 찾을 때까지 이 과정을 반복한다

예제
p = 67, q = 53

### 2. p와 q를 곱해 n을 만든다

n = 67 * 53 = 3551



### 3. p, q와 특수한 수학적 관계인 e를 찾는다

1. n의 카마이클 수를 구한다 `λ(n) = lcm(p - 1, q - 1)`(λ(n): '카마이클 함수'. lcm: 최소공배수. p와 q가 소수일 때만 성립한다.)

λ(n) = lcm(66, 52) = 1716

2. 1 < e < λ(n)이고 λ(n)과 서로소인 e값을 찾는다
  - 서로소: 공약수가 1뿐인 두 정수
  - e값은 위 조건을 만족하면 어떤 것이든 상관없음

e = 19

1 < 19 < 1716

19는 소수이며, 1716 % 19 = 6(19의 몇 배가 1716인지만 알면 된다)


### 4. e와 특수한 수학적 관계인 d를 찾는다

`de === 1(mod λ(n))`

- 위 조건 만족하는 d를 찾음
- 확장 유클리드 호제법 사용하면 쉽게 찾을 수 있다
- e와 λ(n)이 서로소이면 반드시 위 조건을 만족하는 d가 존재

e = 19

λ(n) = 1716

d = 271(알아서 찾았다고 치고...)

271 * 19 % 1716 = 1

여기까지 했으면 RSA에 사용할 키는 다 만든 것.

이제 암호화/복호화가 가능. 순수히 값 대입만 하면 된다. 왜 그렇게 작동하는지 이해하는 게 어렵지, 암호화/복호화는 어렵지 않다.

p = 67, q = 53, n = 3551, λ(n) = 1716, e = 19, d = 271








<br>

# RSA를 이용한 암호화/복호화

## RSA를 이용한 암호화

`m^e % n = c`

- m: 원문
  - 이진수로 표현되어 있으니 당연히 숫자
  - 반드시 m < n이어야 함
    - 아니라면 패딩 등을 통해 m < n이 되도록 변환
- c: 암호문

### 예시:

p = 67, q = 53, n = 3551, λ(n) = 1716, e = 19, d = 271

m = 65(아스키 'A')

65^19 % 3551 = 2935


## RSA를 이용한 복호화

`c^d % n = m`

- c: 암호문
- m: 원문

### 예시:

2935^271 % 3551 = 65

> 아니 이게 어떻게 돼..?라고 한다면 이 연산이 보장되도록 e와 d를 선택했기 때문..! 증명 과정을 간단히 보자(다음)







<br>

# (교양)RSA 증명 1 & 2

(영상 참고...)



