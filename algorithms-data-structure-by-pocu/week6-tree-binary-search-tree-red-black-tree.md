# 트리, 이진 탐색 트리, 레드-블랙 트리


# 트리 소개

트리는 실무에서 사용할 일이 굉장히 많다. 특정한 제약을 가진 트리란 자료구조 덕분에 효율적인 알고리즘을 많이 돌릴 수도 있고, 그래서 이 자료구조는 잘 알아야 한다.

재귀적인 사고방식 또한 매우 중요. 트리 자체가 재귀적 알고리즘을 돌릴 수 있게 하는 자료구조이고, 트리를 사용하겠다는 것은 곧 재귀적인 알고리즘을 사용하겠다는 얘기이기도 하다.

## 트리

- 매우 널리 사용하는 자료구조 중 하나
- 나무(tree)의 계층적 구조를 표현






<br>

# 트리 관련 용어

- 노드*node*: 실제로 저장하는 데이터
- 루트*root* 노드: 최상위에 위치한 데이터
  - 시작 노드
  - 모든 노드와 직간접적으로 연결됨
- 리프*leaf* 노드: 마지막에 위치한 데이터들
  - 더 이상 가지를 치지 않음
- 부모-자식: 연결된 노드들 간의 상대적 관계
  - 자식은 없을 수도, 많이 있을 수도
  - 부모는 언제나 1
  - 조부모/삼촌/형제자매 등도 있음
- 깊이*depth*: 노드 -> 루트 경로의 길이
- 높이*height*: 노드 -> 리프 경로의 ***최대*** 길이
  - '어떤 노드의 높이'가 아니라 어떤 트리의 높이'라고 말할 때가 있다. 해당 경우 루트에서 시작해서 가장 긴 경로를 말하는 것.
- 하위 트리*subtree*: 어떤 노드 아래의 모든 것을 포함하는 트리
  - 리프 노드 하나도 트리라고 볼 수 있고 하나로 카운트한다.
  - 재귀적: 하위 트리 그 자체가 트리!








<br>

# 트리의 저장법 및 용도

## 트리의 저장법

```java
public class Node {
  public int data;
  public ArrayList<Node> children;
}
```

- 트리의 속성
  1. 부모와 자식 모두 노드
  2. 부모:자식 = 1:다수
  3. 자식은 언제나 부모로부터 가지를 침

### 자식이 최대 둘인 트리의 저장법

```java
public class Node {
  public int data;
  public Node left;
  public Node right;
}
```

이런 제약이 걸린 트리를 이진(binary) 트리라고 한다.

### 자식이 최대 하나인 트리의 저장법

```java
public class Node {
  public int data;
  public Node child;
}
```

## 트리의 용도

- ***계층적 데이터를 표현***
  - HTML이나 XML의 문서 개체 모델(DOM)을 표현
  - JSON이나 YAML 처리 시 계층 관계를 표현
  - 프로그래밍 언어를 표현하는 추상 구문 트리(abstract syntax tree)
  - 인간 언어를 표현하는 파싱 트리(parsing tree)
- 검색 트리를 통해 효율적인 검색 알고리듬 구현 가능
- 그 외 다수




<br>

# 이진 탐색 트리

# 이진 트리

- 자식이 최대 둘
  - 왼쪽/오른쪽 자식
- 무언가 계층적(재귀적)으로 이분해 나갈 때 적합

## 이진 트리 -> 이진 탐색 트리

- 자식이 최대 둘
  - 왼쪽/오른쪽 자식
- 무언가 계층적(재귀적)으로 이분해 나갈 때 적합
- 그 무언가를 이분하는 기준을 만든다면?
  - 그 기준에 따라 특화된 이진 트리를 만들 수 있음
  - 그에 따라 보다 효율적인 알고리즘 고안 가능
  - 한 가지 예인 이진 탐색 트리(binary search tree, BST)를 통해 익혀보자

이진 트리 -> 탐색에 특화된 어떤 기준을 만들자 -> 이진 탐색 트리

## 이진 탐색 트리(BST)
- 이진 트리에 이분하는 규칙 추가
  - '왼쪽 자식은 언제나 부모보다 작다'
  - '오른쪽 자식은 언제나 부모보다 크다'
- 정렬된 트리(=정렬된 자료구조)

## 순서대로 BST 읽기 - 깊이 0

- 루트 노드부터 시작
- 다음 단계를 재귀적으로 실행(***중위 순회법in-order traversal***)
  - 왼쪽 하위 트리의 노드를 나열
  - 내 노드를 나열
  - 오른쪽 하위 트리의 노드를 나열

> ***정렬된 자료구조의 이점: 정렬된 자료구조에 특화된 효율적인 알고리즘을 사용할 수 있다***





<br>

# BST 탐색

## 이진 탐색 트리(BST)

- 이진 트리에 이분하는 규칙을 추가
  - 왼쪽 자식은 언제나 부모보다 작다
  - 오른쪽 자식은 언제나 부모 이상
- 정렬된 트리(=정렬된 자료구조)
- 효율적인 알고리즘이 존재
  - 예: 이진 탐색

정렬된 트리와 정렬된 배열의 차이점은?

## 정렬된 배열 vs 이진 탐색 트리

|정렬된 배열|이진 탐색 트리|
|---|---|
|보통 이진 탐색 전에 정렬. 삽입/삭제시마다 정렬도 가능|탐색 전에 따로 정렬 불필요|
|새로 추가된 데이터는 비정렬 상태|데이터 추가시 정렬된 위치에 추가|
|(일단 정렬 후)탐색 시간 O(logN)|탐색 시간 O(logN)|
|삽입 및 삭제 O(n)|평균 삽입/삭제 시간 O(logN)|
|매우 간단한 자료구조|연결 리스트 이상 복잡한 데이터 구조|
|메모리 한 덩어리|보통 여러 메모리 덩어리|


## BST 탐색

- 기본적으로 이진 탐색과 동일
  - 분할 정복(재귀적)
- 차이점
  - 각 노드마다 두 하위 트리로 이분
- 하위 트리 내려갈 때마다
  - 검색 공간이 절반씩 줄어듬
  - O(logN)
- 최악: O(n)
  - 사실상 연결 리스트








<br>

# BST 탐색 코드

## BST 탐색 코드
```java
public class Node {
  private final int data;
  private Node left;
  private Node right;

  public Node(final int data) {
    this.data = data;
  }

  public int getData() {
    return this.data;
  }

  public Node getLeft() {
    return this.left;
  }

    public Node getRight() {
    return this.right;
  }
}
```

```java
public static Node getNodeOrNull(Node node, int data) {
  if (node == null) {
    return null;
  }

  if (node.data == data) {
    return node;
  }

  if (data < node.data) {
    return getNodeOrNull(node.left, data);
  }

  if (data > node.data) {
    return getNodeOrNull(node.right, data);
  }
}
```





<br>

# BST 삽입

## BST 삽입 정리

1. 새로운 노드를 받아줄 수 있는 부모 노드를 찾음 -> O(logN)
  - 트리를 내려가는 방법은 탐색과 같음
  - 새로운 노드를 받아줄 수 있는 부모란?
    - 오른쪽 하위 트리로 내려가야 하는데 오른쪽 자식이 없는 부모
    - 왼쪽 하위 트리로 내려가야 하는데 왼쪽 자식이 없는 부모
2. 그 후, 거기에 자식으로 추가 -> O(1)







<br>

# BST 삽입의 시간 복잡도

O(logN) + O(1)

## BST 삽입은 실제 나무와 비슷

- 이미 자라있는 부분(나뭇가지, 몸통 등)을 유지
  - 기존 노드 위치를 하나도 바꾸지 않음
- 새로운 가지를 뻗어나갈 뿐
  - 새로 추가되는 값은 언제나 리프 노드!






<br>

# 코드보기: BST 삽입

```java
public class Node {
  private final int data;
  private Node left;
  private Node right;

  public Node(final int data) {
    this.data = data;
  }

  public int getData() {
    return this.data;
  }

  public Node getLeft() {
    return this.left;
  }

    public Node getRight() {
    return this.right;
  }
}
```

```java
public static Node insertRecursive(final Node node, int data) {
  if (node == null) {
    return new Node(data);
  }

  if (data < node.data) {
    node.left = insertRecursive(node.left, data);
  } else {
    node.right = insertRecursive(node.right, data);
  }

  return node;
}
```








<br>

# BST 삭제

## 곧바로 자식을 연결하면 안 되는 이유

- BST는 정렬된 배열과 개념상 같다고 했음
  - 중위 순회를 하면 정렬된 배열이 나옴
- 따라서 노드를 삭제한 뒤에도 올바른 BST를 유지하려면?
  - 정렬된 배열에서 값을 하나 삭제하듯이 처리
- 힌트: 트리에서 뭔가를 지울 때 언.제.나. 리프를 지움
  - 실세계에서 나무를 정리할 때도 가지부터 치는 것과 마찬가지 원리


## BST 삭제

오른쪽 하위 트리에서 최솟값(제일 왼쪽 리프, in-order successor)

왼쪽 하위 트리에서 최댓값(제일 오른쪽 리프, in-order predecessor)


## BST 노드 삭제 전략

1. 지울 값을 가지고 있는 노드 탐색 
2. 그 바로 전 값을 가진 노드를 찾음(1~2 -> O(logN))
  - 왼쪽 하위 트리의 제일 오른쪽 리프
3. 두 값을 교환 -> O(1)
4. 리프 노드를 삭제 -> O(1)






<br>

# 트리 순회(tree traversal)

- 대표적인 3가지 트리 순회법
  - 전위(pre-order) 순회
  - 중위(in-order) 순회
  - 후위(post-order) 순회
- 하위 트리와 비교했을 때 현재 노드의 방문 순서
  - 중위: 왼쪽 하위 트리 -> 현재 노드 -> 오른쪽 하위 트리
  - 전위: 현재 노드 -> 왼쪽 하위 트리 -> 오른쪽 하위 트리
  - 후위: 왼쪽 하위 트리 -> 오른쪽 하위 트리 -> 현재 노드

## 중위 순회 코드

```java
public static void traverseInOrder(Node node) {
  if (node == null) {
    return;
  }

  traverseInOrder(node.left);
  System.out.println(node.data);
  traverseInOrder(node.right);
}
```








<br>

# 전위 순회, 후위 순회

## 전위 순회

- 루트 노드부터 시작
- 다음 단계를 재귀적으로 실행
  - 내 노드를 먼저 나열
  - 왼쪽 하위 트리의 노드를 나열
  - 오른쪽 하위 트리의 노드를 나열

근데 이걸 대체 어디다 쓸까?(이 순서로는 배열로 출력시 정렬도 안됨)

## 전위 순회의 용도1 - 트리 복사

- 부모가 있어야 자식도 추가할 수 있음
- 따라서 전위 순회가 적합
  - 부모를 먼저 나열
  - 다른 순회는 부모가 중간 혹은 마지막
- 물론 다른 순회로도 복사는 가능
  - 직관적이지 않을 뿐

## 전위 순회의 용도2 - 수식의 전위 표기법

- 수식은 보통 중위 표기법(infix notation)을 사용
  - 괄호로 우선 순위를 정해줄 수 있음
  - 아래 트리를 중위 순회하면 다음 수식이 나옴: A * (B - C) - (D + E)

아래 같은 트리를 '표현식 트리expression tree'라고도 한다.

```
     -
   /   \
  *     +
 / \    /\
A   -  D  E
   / \
  B   C
```

- 전위 표기법(prefix notation)
  - 폴란드 표기법(Polish notation)이라고도 불림
  - 연산자/괄호의 우선 순위가 없음 (읽는 순서대로!) 따라서 컴퓨터로 계산하기 좀더 편함
  - 위 트리를 표현시 다음 수식이 나옴: -* A - BC + DE
    - (스택을 활용해 오른쪽 -> 왼쪽 순으로 요소 2개 + 연산기호 1개 단위 연산)

## 후위 순회

- 방금 본 예는 후위 순회로 더 쉽게 구현 가능
  - 앞에서부터 읽으면서 스택에 집어넣으면 끝!
- 후위 표기법(postfix notation)
  - 역 폴란드 표기법(reverse Polish notation): ABC -* DE +-
  - (컴퓨터에서 구현하기 더 친화적(앞은 수학자들이 생각하는 방식(오른쪽 -> 왼쪽)에 더 가깝고, 컴퓨터에선 왼쪽 -> 오른쪽 순으로 읽는게 더 일반적))






<br>

# 전위/중위/후위 선택법

## 전위/중위/후위 순회

- 앞에서 본 예 외에도 알고리즘에 따라 셋 중 하나 사용
- 간단한 가이드
  - 리프보다 루트를 먼저 봐야 한다면 전위 순회
  - 리프를 다 본 다음에 다른 노드를 봐야 한다면 후위 순회
  - 순서대로 봐야 한다면 중위 순회


## BST 끝!

- BST는 '이진 트리 + a'
- a
  - 왼쪽 자식은 언제나 부모보다 작다
  - 오른쪽 자식은 언제나 부모 이상

앞에 잠시 스쳐간 것 중 또 '이진 트리 + a'가 있었다. 힙 정렬에서 본 힙이라는 자료구조. 흔히 사용하진 않으니 있다는 것만 참고.






<br>

# 코드보기: 깊은 트리 복사

```java
public static Node copyRecursive(final Node node) {
  if (node == null) {
    return null;
  }

  Node newNode = new Node(node.data);
  newNode.left = copyRecursive(node.left);
  newNode.right = copyRecursive(node.right);

  return newNode;
}
```







<br>

# 레드-블랙 트리

- 학습 목표
  - 개념 이해 중요!
  - 삽입, 삭제 감을 잡는게 중요하다!

## 레드-블랙 트리(red-black tree)
- 각 노드가 레드 혹은 블랙
  - 노드에 저장하는 데이터가 아님 - 얘 아니면 쟤 라고 표기만 해주는 것. 어떤 편의를 위해 색을 칠하는 것 뿐.
  - 그냥 1비트짜리 추가 정보(굳이 빨강/검정 아니어도 됨)
- ***스스로 균형을 잡는(self-balancing)*** 트리
  - 그걸 통해 트리 높이를 최소로 보장
  - 균형을 잡는 시점은 삽입과 삭제 시
  - 그 외 연산은 BST와 동일(단, 탐색 속도가 BST보다 빠를 것임)

균형? -> 레드와 블랙 노드 사이의 균형!







<br>

# 레드-블랙 트리의 특성/속성(properties)

## 레드-블랙 트리의 특성/속성(properties)

레드-블랙 트리가 보장하는 특성/속성

1. 노드는 레드 또는 블랙이다.
  - 레드-블랙 트리에선 null pointer들도 노드(leaf node)로 본다.
2. 루트 노드는 블랙이다(언제나 블랙이어야 한다).
3. 모든 리프 노드(NIL)는 블랙이다.
4. 레드 노드의 자식은 모두 블랙이다.
5. ***어떤 노드와 리프 사이에 있는 블랙 노드 수는 동일하다.***
  - 블랙 노드에만 있는 제약
  - 이를 통해 블랙과 레드 노드 수의 균형을 맞춤
  - 이걸 위해 삽입/삭제 시 트리를 재배치하거나 노드의 색을 바꾸기도 함

## 이런 특성의 영향
- 리프 노드는 데이터를 담지 않음(NIL) :이게 없으면 위 4번, 5번 규칙을 지키기 굉장히 어려울 것. 그걸 보장하기 위해 이 조건도 있는 것.
- 다음과 같은 용어가 탄생
  - ***블랙 깊이(black depth)***: 루트와 어떤 노드 사이에 있는 블랙 노드 수
  - ***블랙 높이(black height)***: 어떤 노드와 리프 사이에 있는 블랙 수
- 가장 큰 리프 깊이가 가장 작은 것의 2배를 넘지 않음
  - 레드-블랙 트리가 보장하는 핵심 특성!
  - 이진 트리 연산 시간이 O(N)이 되는 최악의 경우를 방지 -> O(logN)을 보장
  - C++의 std::map의 구현으로 일반적으로 사용되는 자료구조!

## 레드-블랙 트리가 보장하는 핵심 특성의 "증명"
- 블랙 높이가 x인 트리가 있다고 해보자
- 루트 -> 리프의 길이가 최소인 경우는?
  - 블랙: x개
  - 레드: 0개
- 이제 레드 노드를 최대한 집어넣으려 시도하면?
  - 블랙 노드 사이에 하나씩만 넣을 수 있음
- 따라서 루트 -> 리프의 최대 길이는 2x개의 노드로 구성
  - 참고: NIL 리프 노드는 세지 않았음







<br>

# 레드-블랙 트리의 삽입 방법

## 레드-블랙 트리의 연산

- 탐색: 이진 탐색 트리와 같음
  - 단, O(logN)을 보장
- 삽입과 삭제
  - 일단 무작정 삽입 혹은 삭제(특성이 망가질 수 있음)
  - 그 후, 망가진 특성을 고치려 트리의 구조를 재배치(회전) 혹은 노드 색을 바꿈
  - 완벽하진 않지만 탐색 시간 O(log N)을 보장할 정도의 균형!
  - 이 모두 O(log N)
    - 삽입 또는 삭제 O(log N) <- 트리 깊이가 보장되기 때문
    - 트리 회전: O(1)
    - 색 바꾸기: O(1)

## 일반적인 레드-블랙 트리 삽입 강의

- 다른 강의들은 삽입/삭제 전략(strategy)을 보여주기만 함
- 그리고 그걸 그냥 베껴서 코드로 옮기라 함(...)
- 삽입/삭제 전략이란?
  - 여러 가지 상황들에 대한 대응책을 패턴화 시킨 방법
    - 삽입: 4가지 패턴
    - 삭제: 6가지 패턴
  - 일반적인 사람들은 여러 상황에서 패턴을 찾아내 규칙을 만들기 힘듬
  - 반복/재귀적인 알고리즘이라 더 어렵다.
  - 비유: 바둑판 배치에 따라 다음 돌 놓을 위치 가르치기

## 레드-블랙 트리의 삽입/삭제 원리

- 삽입/삭제 원리를 스스로 알아내는 건 아마 천재의 영역
  - 사실 완전히 이해하는 것 조차 쉽지 않음
- 하지만 실무자라면 최소한 감은 잡아야 함
- 그 감에 의존해서 이런 일이 가능
  - 데이터를 보고 레드-블랙 트리를 적용해야 하는 상황을 인지
  - 실제 코드를 구현하고 적절한 데이터로 테스트
  - 추가 리서치

## POCU의 접근법

- 몇 가지 예를 먼저 봄
  - 즐거운 문제 풀이
  - 망가진 레드-블랙 트리의 특성을 돌려놓기 위한 ~~삽질~~노력
- 그 후 삽입/삭제 전략을 소개
- 기술면접에서 물어보는 일도 드물지만...
  - 레드-블랙 트리의 특성을 유지하려 이런저런 시도를 하며 이해하는 건 좋음
  - 특히 재귀적 사고방식에 도움
- 삽입은 최대한 규칙을 끌어내 보려 노력할 것임


## 레드-블랙 트리의 삽입 방법(큰 그림)
1. BST와 똑같이 삽입
  - 단, 새로 삽입하는 노드는 언제나 레드
  - 언제나 리프에 추가되니 아래 연산이 간단해짐
2. 레드-블랙 트리의 조건을 만족하도록 재귀적으로 고침 
  - 재귀 방향: 리프로부터 위로 올라가면서
  - 고칠 때 사용하는 기법은 다음 두 가지
    - 트리 회전(tree rotation)
    - 색깔 바꾸기
  - 총 4가지 상황 (패턴)에 따라 트리 회전, 색깔 바꾸기 기법을 다르게 적용






<br>

# 레드-블랙 트리 삽입 전략

## 레드-블랙 트리 삽입의 시간 복잡도

- 노드를 리프에 삽입 -> O(logN)
- 새 노드 색을 레드로 칠함 -> O(1)
- 망가진 레드-블랙 트리의 특성을 고침 -> O(logN)
  - 색상 바꾸기: O(1)
  - 트리 회전: O(1)

O(logN)


## 새 노드가 오른쪽에 추가되는 경우에는?
- 여태까지 예는 모두 왼쪽 하위 트리에 새 노드가 추가됨
- 오른쪽에 추가되어도 해법은 똑같음
  - 트리 회전할 때 방향만 반대로 하면 됨
- 이 4가지 상황(case)을 잘 정리한 게 앞에서 언급한 전략 (strategy)
  - 이걸 굳이 암기하고 있을 필요는 없음
  - 보통 필요할 때마다 찾아보며 해결

`https://en.wikipedia.org/wiki/Red%E2%80%93black_tree`

## (supplementarty)레드-블랙 트리 삽입 전략 - Case1

- 상황: 현재 노드 N이 트리의 루트
- 전략: N을 블랙으로 바꾼다

## (supplementarty)레드-블랙 트리 삽입 전략 - Case2

- 상황: N의 부모 P가 블랙
- 전략: 아무 것도 안 함

## (supplementarty)레드-블랙 트리 삽입 전략 - Case3

- 상황: P와 삼촌 U가 모두 레드, 조부모 G는 블랙
- 전략: P, U, G의 색을 바꾼다
- G부터 다시 실행!

## (supplementarty)레드-블랙 트리 삽입 전략 - Case4 단계1

- 상황: P는 레드, U는 블랙
- 전략: N이 하위 트리의 안쪽에 있지 않도록 회전
- 그리고 단계 2로 진행

## (supplementarty)레드-블랙 트리 삽입 전략 - Case4 단계2

- 상황: 이제 N이 하위 트리의 바깥쪽에 있음
- 전략: G에서 우회전 후 P와 G의 색을 바꿈







<br>

# 레드 블랙 트리의 삭제 방법

## 일반적인 레드-블랙 트리 삭제 강의

- 웬만한 강의에서 설명도 없이 은근슬쩍 넘어가는 내용
- 하더라도 전략의 암기를 돕기 위해 이상한 비유를 듬
  - 레드는 화난 상태, 블랙은 차분한 상태
  - '니가 아버지의 차분함을 가져가고 아버지를 화나게 만들어서 니 형이 화가 나' 등
- 케이스만 6개
  - 케이스 적용 전에 미리 전처리를 해야 함

## POCU의 접근법
- 몇 가지 예를 보면서 감만 잡으려 노력
  - 쉬운 문제들은 혼자 풀 수 있을 것임
  - 적당히만 어려워도 스스로 답을 찾기 어려움
- 문제를 풀다가 전략을 도출하려는 노력따위 하지 않음(...)
- 문제 다 푼 뒤에는 그냥 전략을 보고 끝

## 레드-블랙 트리의 삭제 방법(큰 그림)

1. BST에서 삭제하듯이 우선 삭제한다
  - 지우려는 값을 가진 노드를 찾음
  - 교환할 NIL 아닌 노드 M을 찾음
  - 값을 복사해옴(색은 복사 안 함)
  - M을 지움
2. 레드-블랙 트리의 특성이 망가진 걸 고치려 열심히 노력한다(...)

## 자식의 경우의 수는 생각보다 간단

- M은 언제나 오른쪽 하위 트리의 최솟값
  - (또는 왼쪽 하위 트리의 최댓값)
  - M의 왼쪽에 다른 값이 있을 수 없음
    - BST의 삭제 방법 때문
  - 오른쪽에는 값이 있을 수 있음
- 결국 다음과 같은 자식을 가진 노드를 지우는 문제
  - 자식이 모두 NIL
  - 자식 중 하나만 NIL
- 따라서 이런 경우만 볼 계획 <- 중요! 꼭 기억!






<br>

# MC THE BLACK

레드-블랙 트리 삭제에 있어 복잡한 문제는 M과 C가 모두 BLACK일 때만 생긴다.

## M과 C가 모두 블랙일 때만 문제인 이유

- M이 레드면 C는 반드시 블랙
  - 이건 쉬운 경우임을 이미 봤음
- M이 블랙이고 C가 레드인 경우는?
  - C의 한 쪽 자식은 무조건 NIL(BST의 삽입 규칙에 따라)
  - C의 다른 쪽 자식이 레드일 순 없음
  - C의 다른 쪽 자식이 NIL이 아닌 블랙일 수도 없음
  - C의 자식은 무조건 NIL!
  - 아주 간단히 해결!





<br>

# (supplementary)레드-블랙 삭제 전략1

## 레드-블랙 삭제 전략(개요)

- 총 6 개 case
- 트리가 망가진 걸 고치기 위해 사용
  - M, C가 모두 블랙일 때
  - M 삭제 후, N을 기준으로 
- 다음처럼 재귀적으로 작동(영상 참고...)

## 레드-블랙 트리 삭제의 시간 복잡도

- BST 방식으로 노드를 제거 -> O(logN)
- 망가진 레드-블랙 트리의 특성을 고침 -> O(logN)
  - 색상 바꾸기: O(1)
  - 트리 회전: O(1)



