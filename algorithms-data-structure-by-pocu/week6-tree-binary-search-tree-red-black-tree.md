# 트리, 이진 탐색 트리, 레드-블랙 트리


# 트리 소개

트리는 실무에서 사용할 일이 굉장히 많다. 특정한 제약을 가진 트리란 자료구조 덕분에 효율적인 알고리즘을 많이 돌릴 수도 있고, 그래서 이 자료구조는 잘 알아야 한다.

재귀적인 사고방식 또한 매우 중요. 트리 자체가 재귀적 알고리즘을 돌릴 수 있게 하는 자료구조이고, 트리를 사용하겠다는 것은 곧 재귀적인 알고리즘을 사용하겠다는 얘기이기도 하다.

## 트리

- 매우 널리 사용하는 자료구조 중 하나
- 나무(tree)의 계층적 구조를 표현






<br>

# 트리 관련 용어

- 노드*node*: 실제로 저장하는 데이터
- 루트*root* 노드: 최상위에 위치한 데이터
  - 시작 노드
  - 모든 노드와 직간접적으로 연결됨
- 리프*leaf* 노드: 마지막에 위치한 데이터들
  - 더 이상 가지를 치지 않음
- 부모-자식: 연결된 노드들 간의 상대적 관계
  - 자식은 없을 수도, 많이 있을 수도
  - 부모는 언제나 1
  - 조부모/삼촌/형제자매 등도 있음
- 깊이*depth*: 노드 -> 루트 경로의 길이
- 높이*height*: 노드 -> 리프 경로의 ***최대*** 길이
  - '어떤 노드의 높이'가 아니라 어떤 트리의 높이'라고 말할 때가 있다. 해당 경우 루트에서 시작해서 가장 긴 경로를 말하는 것.
- 하위 트리*subtree*: 어떤 노드 아래의 모든 것을 포함하는 트리
  - 리프 노드 하나도 트리라고 볼 수 있고 하나로 카운트한다.
  - 재귀적: 하위 트리 그 자체가 트리!








<br>

# 트리의 저장법 및 용도

## 트리의 저장법

```java
public class Node {
  public int data;
  public ArrayList<Node> children;
}
```

- 트리의 속성
  1. 부모와 자식 모두 노드
  2. 부모:자식 = 1:다수
  3. 자식은 언제나 부모로부터 가지를 침

### 자식이 최대 둘인 트리의 저장법

```java
public class Node {
  public int data;
  public Node left;
  public Node right;
}
```

이런 제약이 걸린 트리를 이진(binary) 트리라고 한다.

### 자식이 최대 하나인 트리의 저장법

```java
public class Node {
  public int data;
  public Node child;
}
```

## 트리의 용도

- ***계층적 데이터를 표현***
  - HTML이나 XML의 문서 개체 모델(DOM)을 표현
  - JSON이나 YAML 처리 시 계층 관계를 표현
  - 프로그래밍 언어를 표현하는 추상 구문 트리(abstract syntax tree)
  - 인간 언어를 표현하는 파싱 트리(parsing tree)
- 검색 트리를 통해 효율적인 검색 알고리듬 구현 가능
- 그 외 다수




<br>

# 이진 탐색 트리

# 이진 트리

- 자식이 최대 둘
  - 왼쪽/오른쪽 자식
- 무언가 계층적(재귀적)으로 이분해 나갈 때 적합

## 이진 트리 -> 이진 탐색 트리

- 자식이 최대 둘
  - 왼쪽/오른쪽 자식
- 무언가 계층적(재귀적)으로 이분해 나갈 때 적합
- 그 무언가를 이분하는 기준을 만든다면?
  - 그 기준에 따라 특화된 이진 트리를 만들 수 있음
  - 그에 따라 보다 효율적인 알고리즘 고안 가능
  - 한 가지 예인 이진 탐색 트리(binary search tree, BST)를 통해 익혀보자

이진 트리 -> 탐색에 특화된 어떤 기준을 만들자 -> 이진 탐색 트리

## 이진 탐색 트리(BST)
- 이진 트리에 이분하는 규칙 추가
  - '왼쪽 자식은 언제나 부모보다 작다'
  - '오른쪽 자식은 언제나 부모보다 크다'
- 정렬된 트리(=정렬된 자료구조)

## 순서대로 BST 읽기 - 깊이 0

- 루트 노드부터 시작
- 다음 단계를 재귀적으로 실행(***중위 순회법in-order traversal***)
  - 왼쪽 하위 트리의 노드를 나열
  - 내 노드를 나열
  - 오른쪽 하위 트리의 노드를 나열

> ***정렬된 자료구조의 이점: 정렬된 자료구조에 특화된 효율적인 알고리즘을 사용할 수 있다***





<br>

# BST 탐색

## 이진 탐색 트리(BST)

- 이진 트리에 이분하는 규칙을 추가
  - 왼쪽 자식은 언제나 부모보다 작다
  - 오른쪽 자식은 언제나 부모 이상
- 정렬된 트리(=정렬된 자료구조)
- 효율적인 알고리즘이 존재
  - 예: 이진 탐색

정렬된 트리와 정렬된 배열의 차이점은?

## 정렬된 배열 vs 이진 탐색 트리

|정렬된 배열|이진 탐색 트리|
|---|---|
|보통 이진 탐색 전에 정렬. 삽입/삭제시마다 정렬도 가능|탐색 전에 따로 정렬 불필요|
|새로 추가된 데이터는 비정렬 상태|데이터 추가시 정렬된 위치에 추가|
|(일단 정렬 후)탐색 시간 O(logN)|탐색 시간 O(logN)|
|삽입 및 삭제 O(n)|평균 삽입/삭제 시간 O(logN)|
|매우 간단한 자료구조|연결 리스트 이상 복잡한 데이터 구조|
|메모리 한 덩어리|보통 여러 메모리 덩어리|


## BST 탐색

- 기본적으로 이진 탐색과 동일
  - 분할 정복(재귀적)
- 차이점
  - 각 노드마다 두 하위 트리로 이분
- 하위 트리 내려갈 때마다
  - 검색 공간이 절반씩 줄어듬
  - O(logN)
- 최악: O(n)
  - 사실상 연결 리스트








<br>

# BST 탐색 코드

## BST 탐색 코드
```java
public static Node getNodeOrNull(Node node, int data) {
    if (node == null) {
    return null;
  }

  if (node.data == data) {
    return node;
  }

  if (data < node.data) {
    return getNodeOrNull(node.left, data);
  }

  if (data > node.data) {
    return getNodeOrNull(node.right, data);
  }
}
```




















<br>











<br>









<br>











<br>









<br>











<br>









<br>











<br>









<br>











<br>

# 레드-블랙 트리

- 학습 목표
  - 개념 이해 중요!
  - 삽입, 삭제 감을 잡는게 중요하다!

## 레드-블랙 트리(red-black tree)
- 각 노드가 레드 혹은 블랙
  - 노드에 저장하는 데이터가 아님 - 얘 아니면 쟤 라고 표기만 해주는 것. 어떤 편의를 위해 색을 칠하는 것 뿐.
  - 그냥 1비트짜리 추가 정보(굳이 빨강/검정 아니어도 됨)
- ***스스로 균형을 잡는(self-balancing)*** 트리
  - 그걸 통해 트리 높이를 최소로 보장
  - 균형을 잡는 시점은 삽입과 삭제 시
  - 그 외 연산은 BST와 동일(단, 탐색 속도가 BST보다 빠를 것임)

균형? -> 레드와 블랙 노드 사이의 균형!



<br>

# 레드-블랙 트리의 특성/속성(properties)

## 레드-블랙 트리의 특성/속성(properties)

레드-블랙 트리가 보장하는 특성/속성

1. 노드는 레드 또는 블랙이다.
  - 레드-블랙 트리에선 null pointer들도 노드(leaf node)로 본다.
2. 루트 노드는 블랙이다(언제나 블랙이어야 한다).
3. 모든 리프 노드(NIL)는 블랙이다.
4. 레드 노드의 자식은 모두 블랙이다.
5. ***어떤 노드와 리프 사이에 있는 블랙 노드 수는 동일하다.***
  - 블랙 노드에만 있는 제약
  - 이를 통해 블랙과 레드 노드 수의 균형을 맞춤
  - 이걸 위해 삽입/삭제 시 트리를 재배치하거나 노드의 색을 바꾸기도 함

## 이런 특성의 영향
- 리프 노드는 데이터를 담지 않음(NIL) :이게 없으면 위 4번, 5번 규칙을 지키기 굉장히 어려울 것. 그걸 보장하기 위해 이 조건도 있는 것.
- 다음과 같은 용어가 탄생
  - ***블랙 깊이(black depth)***: 루트와 어떤 노드 사이에 있는 블랙 노드 수
  - ***블랙 높이(black height)***: 어떤 노드와 리프 사이에 있는 블랙 수
- 가장 큰 리프 깊이가 가장 작은 것의 2배를 넘지 않음
  - 레드-블랙 트리가 보장하는 핵심 특성!
  - 이진 트리 연산 시간이 O(N)이 되는 최악의 경우를 방지 -> O(logN)을 보장
  - C++의 std::map의 구현으로 일반적으로 사용되는 자료구조!

## 레드-블랙 트리가 보장하는 핵심 특성의 "증명"
- 블랙 높이가 x인 트리가 있다고 해보자
- 루트 -> 리프의 길이가 최소인 경우는?
  - 블랙: x개
  - 레드: 0개
- 이제 레드 노드를 최대한 집어넣으려 시도하면?
  - 블랙 노드 사이에 하나씩만 넣을 수 있음
- 따라서 루트 -> 리프의 최대 길이는 2x개의 노드로 구성
  - 참고: NIL 리프 노드는 세지 않았음





<br>

# 레드-블랙 트리의 삽입 방법

## 레드-블랙 트리의 연산

- 탐색: 이진 탐색 트리와 같음
  - 단, O(logN)을 보장
- 삽입과 삭제
  - 일단 무작정 삽입 혹은 삭제(특성이 망가질 수 있음)
  - 그 후, 망가진 특성을 고치려 트리의 구조를 재배치(회전) 혹은 노드 색을 바꿈
  - 완벽하진 않지만 탐색 시간 O(log N)을 보장할 정도의 균형!
  - 이 모두 O(log N)
    - 삽입 또는 삭제 O(log N) <- 트리 깊이가 보장되기 때문
    - 트리 회전: O(1)
    - 색 바꾸기: O(1)

## 일반적인 레드-블랙 트리 삽입 강의

- 다른 강의들은 삽입/삭제 전략(strategy)을 보여주기만 함
- 그리고 그걸 그냥 베껴서 코드로 옮기라 함(...)
- 삽입/삭제 전략이란?
  - 여러 가지 상황들에 대한 대응책을 패턴화 시킨 방법
    - 삽입: 4가지 패턴
    - 삭제: 6가지 패턴
  - 일반적인 사람들은 여러 상황에서 패턴을 찾아내 규칙을 만들기 힘듬
  - 반복/재귀적인 알고리즘이라 더 어렵다.
  - 비유: 바둑판 배치에 따라 다음 돌 놓을 위치 가르치기

## 레드-블랙 트리의 삽입/삭제 원리

- 삽입/삭제 원리를 스스로 알아내는 건 아마 천재의 영역
  - 사실 완전히 이해하는 것 조차 쉽지 않음
- 하지만 실무자라면 최소한 감은 잡아야 함
- 그 감에 의존해서 이런 일이 가능
  - 데이터를 보고 레드-블랙 트리를 적용해야 하는 상황을 인지
  - 실제 코드를 구현하고 적절한 데이터로 테스트
  - 추가 리서치

## POCU의 접근법

- 몇 가지 예를 먼저 봄
  - 즐거운 문제 풀이
  - 망가진 레드-블랙 트리의 특성을 돌려놓기 위한 ~~삽질~~노력
- 그 후 삽입/삭제 전략을 소개
- 기술면접에서 물어보는 일도 드물지만...
  - 레드-블랙 트리의 특성을 유지하려 이런저런 시도를 하며 이해하는 건 좋음
  - 특히 재귀적 사고방식에 도움
- 삽입은 최대한 규칙을 끌어내 보려 노력할 것임


## 레드-블랙 트리의 삽입 방법(큰 그림)
1. BST와 똑같이 삽입
  - 단, 새로 삽입하는 노드는 언제나 레드
  - 언제나 리프에 추가되니 아래 연산이 간단해짐
2. 레드-블랙 트리의 조건을 만족하도록 재귀적으로 고침 
  - 재귀 방향: 리프로부터 위로 올라가면서
  - 고칠 때 사용하는 기법은 다음 두 가지
    - 트리 회전(tree rotation)
    - 색깔 바꾸기
  - 총 4가지 상황 (패턴)에 따라 트리 회전, 색깔 바꾸기 기법을 다르게 적용







