# 그래프2

# 그래프의 너비 우선 탐색


## 너비 우선 탐색

* 트리에서 봤던 너비 우선 탐색
* 원래는 그래프에 사용 가능한 것
  * 트리는 특별한 제약이 있는 그래프
  * 깊이 우선 탐색도 마찬가지였음
* 단, 방문한 노드를 기억해야 함
  * 실제로는 발견한 노드를 기억
  * 깊이 우선 탐색에서 이미 본 것


## 그래프의 너비 우선 탐색 코드

```java
public static void searchBreadthFirst(Node node) {
	HashSet<Node> discovered = new HashSet<>();
	Queue<Node> queue = new LinkedList<>();

	queue.add(node) ;
	discovered.add(node);

	while (!queue. isEmpty()) {
		Node next = queue.remove;
		System.out.print(next.data + " ");

		for (Node neighbor : next.neighbors) {
			if (!discovered.contains(neighbor)) {
				queue.add (neighbor); 
				discovered.add (next);
			}
		}
	}
}
```





<br><br><br>

---

# 그래프 BFS의 시간 복잡도

> O(N + E)









<br><br><br>

---

# 최단 경로 찾기

# 최단 경로 찾기(shortest path)

* 집에서 학교로 가는 길
* 각 변은 두 노드를 연결하는 도로 의미
* 학교로 가는 경로는 여러 가지
* 사실 순환(cycle)이 있기에 경로는 무한
  * ~~학교 가기 싫은 아이~~

가장 짧은 경로를 찾아보자!

![sp](resources/shortest-path.png)

* 가장 간단한 방법은 주먹구구식
  * 모든 가능한 조합을 만든 뒤, 그중 가장 짧은 것을 선택
  * 단, 순환이 없게끔 해야 함
* 하지만 이 방법은 엄청난 시간 복잡도
* BFS를 사용하면 최단 경로를 찾을 수 있음!
  * 시간 복잡도도 O(N + E)!


## BFS가 최단 경로를 찾는 이유

* S는 시작 노드, d는 도착 노드
* 현재 깊이의 모든 노드를 방문 후 다음 깊이로 진행
  * 깊이 n-1에서는 d 노드를 찾지 못했음
  * 깊이 n을 뒤지다 보면 d 노드를 찾음
* 따라서 BFS는 언.제.나. 최단 경로를 찾음!
  * 제대로 된 증명을 보고 싶다면 구글 검색! 'BFS shortest path proof'

![bfs-sp](resources/bfs-sp.png)









 
<br><br><br>

---

# BFS로 최단 경로 찾기

## BFS로 최단 경로 찾기

- 기본적인 BFS와 크게 다르지 않음
- 그러나 시작점부터 현재 노드까지의 거리를 기억해야 함
  - 거리 = BFS 깊이
  - 약간의 코드 수정만 필요!
- 저장법은 여러 가지
  - 해시 맵에 모든 노드의 거리를 저장
  - 2D 배열로 저장(인접 행렬과 비슷한 모습)
  - 각 노드 안에 거리를 저장(BFS를 실행하기 전에 리셋해줘야 함)
    - DFS의 경우와 마찬가지로 엄밀히는 올바른 OOP가 아닐 수 있다.

```java
public static int findShortestDistance(Node s, Node d) {
	HashMap<Node, Integer> distances = new HashMap<>();
	Queue<Node> queue = new LinkedList<>();

	queue.add(s);
	distances.put(s, 0);

	while (!queue.isEmpty()) {
		Node next = queue.remove();
		int distnace = distances.get(next);

		if (next.equals(d)) {
			return distance;
		}

		for (Node neighbor : next.neighbors) {
			if (!distances.containsKey(neighbor)) {
				queue.add(neighbor);
				distances.put(neighbor, distance + 1);
			}
		}
	}

	return -1;
}
```

- 최종 노드부터 반대 방향으로 추적
- 추적을 위해 추가 정보 필요
  - 선행 노드: '누가 나를 큐에 넣었는가?'
  - 큐에 다음 노드를 넣을 때 선행 노드도 같이 기재
- 정보 저장 방법은 여러 가지
  - 해시 맵에 기억(키: 내 노드, 값: 선행 노드)
  - 노드 속에 선행 노드를 기억(BFS 실행 전에 이 값을 리셋해줘야 함)
  - 등

## 각 변의 거리가 다른 최단 경로 찾기

- BFS로 간단히 해결할 수 없음
  - 가중 그래프
  - BFS의 깊이 != 거리

다른 알고리즘이 필요!









<br><br><br>

---

# 다익스트라 알고리즘의 기초

## 다익스트라 알고리즘(Dijkstra's algorithm)

- 두 노드 사이의 최단 경로를 찾음
- 방대한 노드 네트워크에 사용하기 충분히 빠름(몇 천~몇 만+)
- 변의 가중치가 음수인 경우에는 제대로 작동하지 않음
- 실세계에서 많이 사용
  - 지도/내비게이션
  - IP 라우팅
  - 경유 항공편 찾기
  - 등


## 다익스트라 알고리즘의 기초

- 모든 노드를 한 번씩 방문하며 아래의 연산을 함
  1. 아직 방문 안 한 노드 중 가장 가까운 노드 n을 선택
  2. n의 각 이웃 노드 m으로 여행하는 거리를 계산(n의 거리 + n -> m 거리)
  3. 이 결과가 m의 기존 거리보다 가까우면 m의 거리를 업데이트
- 모든 노드를 방문하면 최단 거리를 찾음
  - 모든 노드를 거쳐 온 경로 중 최솟값을 취했기 때문

(TIP: 이런 알고리즘을 처음부터 만들려고 하면 힘들어 못 만든다. 다른 사람이 만들어 놓은 걸 가져와서 쓰면 된다. 이런 그래프 알고리즘들은 내가 어떤 알고리즘을 고안하는 문제보다는 이미 있는 알고리즘에 내 문제를 접목시키는 것. 또는 이 문제가 있고 이 문제가 특정 그래프 알고리즘으로 풀 수 있는 문제라, 그러기 위해선 노드와 변을 어떻게 구성해야 된다라는 걸 디자인해야 하는데, 그게 오히려 어려운 부분이긴 하다. 결국 여러가지 문제를 풀면서 해결하는 방법 밖에 없다.)

어떤 알고리즘 기법이 생각나나요?  
그리디?(가장 가까운 노드 n을 선택...)  
다익스트라는 동적 계획법(DP)!







<br><br><br>

---

# 다익스트라 알고리즘 1

## (supplementary)다익스트라 알고리즘

1. 아직 방문 안 한 노드 중 가장 거리 값이 작은 노드 n을 선택
2. n의 각 미방문 이웃 m으로 가는 더 짧은 경로가 있다면 업데이트
  - min
    - 현재까지 알려진 m의 거리
    - 현재까지 알려진 n의 거리 + n -> m 거리
3. 다음 조건 중 하나를 만족하기 전까지 1~2를 반복
  - 모든 노드를 방문했음
  - n이 목적지임
4. 목적지까지의 거리/경로를 반환








<br><br><br>

---

# 다익스트라 알고리즘 2










<br><br><br>

---

# 다익스트라의 시간 복잡도

## 인접 행렬의 문제

노드는 수백만 개인데 변은 몇 개 안 되면?

eg. 지도 앱  
노드: xx 교차로  
변: 4개  
서울 시내 교차로 수: 그냥 많음(...)  
n^2 -> 수백만^2(...)

따라서 인접 리스트로 만들어야 한다.  
인접 리스트를 사용한단 가정하에 시간 복잡도를 보자.


## 시간 복잡도

- 방문하는 노드 수(=알고리즘 실행 횟수): N
  - 최소 거리 노드 선택: N
- 모든 변을 한 번씩은 지나감: E
  - 거리 값 업데이트: 1

> O(N^2 + E) = O(N^2)


- 최소 거리 노드 선택: N -> logN으로 빠르게 만들 수 있다.
  - 우선순위 큐(이진 힙) 사용시
    - 최소값을 찾을 땐 O(1)이긴 하지만, 제거할 때마다 최소값이 위로 다시 올라와야하고 리밸런싱 해야하는데 그 비용이 O(logN).
- 거리 값 업데이트: 1 -> logN
  - 거리값이 업데이트되면 우선순위 큐에 들어가있던 노드의 구조들이 리밸런싱이 되어야 하므로.

> O(NlogN + ElogN) = O((N + E)logN)

우선순위 큐 대신 BST를 사용해도 시간 복잡도는 같다.


## 더 빠른(?) 자료 구조

- 피보나치 힘을 사용하면 이론 상 시간 복잡도를 더 줄일 수 있음
  - O(E + N log N)
- 우선순위를 다시 정렬하는 시간이 0(1). 거의 대부분의 경우.
  - 최악의 경우 삭제가 O(N)이 걸릴 수도 있음
- 코드로 옮기기 복잡
- 실제 실행 속도는 다른 힙보다 그다지 안 빠를 수 있음
  - 중간에 공간을 더 잡아먹는다던가, 포인터를 더 사용한다던가 등...







<br><br><br>

---

# 다익스트라와 음의 가중치

## 다익스트라와 음의 가중치










<br><br><br>

---










<br><br><br>

---










<br><br><br>

---










<br><br><br>

---










<br><br><br>

---










<br><br><br>

---










<br><br><br>

---










<br><br><br>

---










<br><br><br>

---










<br><br><br>

---