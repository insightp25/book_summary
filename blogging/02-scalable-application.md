[02.v.03] 확장성 있는 고가용성 분산 시스템의  제약 조건과 트레이드오프

저장 기술은 무엇을 선택할까? 확장에 유연하고 결함에 강한 분산 데이터 시스템 구축하기
확장성있는 고가용성 분산 시스템의 제약 조건과 트레이드오프(feat. 데이터 모델, 저장소, 색인)
부하 증가에 대처하는 확장과 고가용성, 그를 따르는 제약조건과 트레이드오프

# 서문

지난 글에서 SNS의 핵심 요구사항으로 반응성(낮은 지연시간)과 가용성을 꼽았고, 대규모 트래픽과 읽기 집중에서 더 나은 반응성을 위한 알고리즘에 대해 생각해 보았다. 다만, 해당 알고리즘은 범용 저장소로 사용되는 관계형 DB를 사용하는 경우와 트래픽이 증가하지 않는 상황을 전제로 하였다.

이번 글에서는 트래픽이 늘어 부하가 증가하는 상황에서 어떻게 계속 낮은 지연시간을 보장할 수 있는지, 네트워크나 노드에 장애가 생기는 경우 어떻게 가용성을 보장할 수 있는지, 또 그에 따르는 제약조건과 트레이드오프는 무엇인지에 대해 알아보며 트위터 API에 적합한 저장소 선택과 데이터 시스템 디자인 과정에 대해 정리해보고자 한다.

<br><br><br><br><br><br><br>

---
# 요구사항 1 - 대용량 데이터와 부하 증가에서 성능 개선 및 유지

## 요구사항 분석
### 점점 빨라지는 서비스 성장 추세와 대용량 데이터 처리

모든 신규 서비스들은 성장과 확장을 기본 전제로 할 것이다. 다만 그 추세가 점점 빨라지고 있다. 트위터는 2013년 초당 4,000회 쓰기 요청에서 2023년 초당 6,000회 쓰기 요청으로 10년간 약 50%의 트래픽이 증가하였다. OpenAI의 ‘ChatGPT’ 서비스는 런칭한지 2개월만에 가입자 1억 명을 돌파했고, 메타의 신규 서비스 ’Threads’는 ChatGPT의 기록을 깨고 불과 5일만에 가입자 1억명을 달성하였다.

### 트위터 API의 요구사항의 특징

트위터의 타임라인(모아보기) 읽기, 트윗 쓰기 등 개별 요청에 요구되는 연산은 단순하다. 하지만 초당 요청 회수가 많아 부하가 발생하는 형태이다. 

또한, 데이터가 비정형적이다. 트위터의 핵심은 타임라인(모아보기)인데, 지난 포스팅의 내용처럼 fan-out을 할 경우 경우 각 유저마다 타임라인을 구성해야 한다. 즉, 유저별로 타임라인이라는 데이터를 저장하게 될 것이고, 모든 유저의 타임라인은 다르게 생겼으며, 또 수시로 변할 것이다. 즉, 데이터가 비정형적이다.

문제를 정의하자면 다음과 같다.

<br>

### 문제 정의

> 1. 어떻게 대용량 데이터와 급격한 부하 증가 상황에서도 5초 이내의 동일한 지연시간을 보장할 수 있을까?
2. 집중적인 단순 연산 처리에 효과적인 방법은 있을까?
3. 비정형 데이터를 어떻게 효과적으로 처리할 수 있을까?


<br>

## 해결 방안

문제 해결을 위한 방법으로 서버 확장이 있을 것이다. 서버 확장의 방법과 그에 따르는 제약상황, 트레이드오프에 무엇이 있는지 알아보자.

### 해결방안 1 - 스케일 업 vs. 스케일 아웃

부하 증가에 대처하기 위한 확장 방법에는 크게 두 가지가 있으며, 각자의 이점과 그 트레이드오프를 비교해보자. 

#### 스케일업

스케일업은 수직확장이라고도 하며, 단일 서버(하드웨어)의 성능을 증가시켜서 더 많은 요청을 처리하는 방법이다. 단일 하드웨어의 성능을 높이기 위해 CPU, 메모리, 하드디스크를 업그레이드 하거나 추가하는 것이다. 

이점

1. 단순성: 확장이 기술적으로는 복잡하지 않다. 단순히 CPU나 RAM, 저장소를 추가하기만 하면 된다.
2. 호환성: 애플리케이션이 분산 환경을 감안하지 않아도 된다.
3. 성능: 집중 연산 능력을 요구하는 일부 작업에 효과적이며, 모든 자원들이 한 하드웨어 내에서 모두 연결돼있으므로 지연이 보다 낮을 수 있다.

트레이드오프

1. 비용: 하드웨어의 성능이 높아질 수록 비용 대비 개선 효과가 줄어들며 비싸다.
2. 물리적 제약: 아무리 좋은 하드웨어와 고사양 부품이 있다고 하더라도 단일 장비에 설치할 수 있는 슬롯에 한계가 있다.
3. 단일 고장점(SPOF, Single Point of Failure): 장애에 취약하다. 만약 고사양의 서버에 장애가 생기면 그만큼 타격이 클 수 밖에 없다.
4. 확장 편의성: 중간에 부하가 늘어나 추가로 확장하기 위해선 스케일업 과정중 백업할 비슷한 사양의 1회성 서버가 한 대가 더 필요하고 불필요한 비용이 발생하게 된다. 또한 늘어나는 속도를 예측하지 못할시 중간에 서버를 중단시켜야 할 수 있고, 기존 서버 데이터를 옮기고 데이터를 정리하려면 그 작업 시간만큼 서비스가 중단될 것이다. 이 작업은 적게는 수 시간에서 많게는 하루 이상이 걸릴 수 있는데, 사용자가 늘어날 때마다 이런 작업을 반복할 수는 없을 것이다.


#### 스케일 아웃

스케일아웃은 수평확장이라고도 하며, 동일 사양의 새로운 서버(하드웨어)를 추가하는 방법이다.

이점

1. 유연성: 필요에 따라 장비를 추가하거나 줄일 수 있어 비용효과적이다.
2. 내결함성: 고가용성을 제공할 수 있고 데이터 분산을 통해 특정 장비의 결함에 보다 단단하다.
3. 확장성: 기본적으로 얼마나 확장할지에 대한 상한이 없으며 계속 노드를 추가할 수 있다.
4. 로드밸런싱: 로드밸런싱을 통해 부하를 고르게 분산시킬 수 있다.

트레이드오프

1. 복잡성: 분산을 위해 더 복잡한 시스템 아키텍처가 필요하며, 소프트웨어가 분산 환경에서 동작할 수 있어야 한다.
2. 관리: 노드가 늘어날 수록 노드를 관리할 수 있는 시스템이 더 많이 필요하게 되며, 운영에 필요한 부하와 복잡성이 증가한다.
3. 네트워크 의존성: 노드간 네트워크 장애나 지연에 취약하다
4. 비일관성inconsistency: 노드간 데이터 일관성과 동기화 이슈가 있을 수 있다.





<br>

### 해결방안2 - 분산 데이터 시스템의 제약조건과 트레이드오프

지난 포스팅의 알고리즘 고안시 관계형 DB를 기준으로 삼았었다. 하지만 과연 관계형 DB가 트위터의 api에 최적일까? 어떤 다른 선택지가 있으며, 어떤 점을 기준으로 살펴봐야 할까?

역사적으로 데이터를 하나의 큰 트리(계층 모델)로 표현하려고 노력했지만 다대다 관계를 표현하기에는 트리 구조가 적절하지 않았다. 이 문제를 해결하기 위해 관계형 모델이 고안됐다. 하지만 개발자들은 관계형 모델에도 적합하지 않은 애플리케이션이 있다는 사실을 발견했다. 또한 상상조차 불가능한 양의 데이터, 그리고 비정형 데이터가 포함된 데이터를 분산해 저장하고 사용하는 방법을 연구하며 NoSQL이라고 불리우는 새로운 데이터 저장소 유형이 등장하였다.

NoSQL의 정의에 대해 명확히 합의된 바는 없지만, 대표적으로 마틴파울러의 정의에 따르면 다음과 같다.

- 대용량 웹 서비스를 위해 만들어진 데이터 저장소
- 관계형 데이터 모델을 지양하며 대량의 데이터를 저장하고 조회하는 데 특화된 저장소
- 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소

핵심은 '관계형 데이터 모델을 사용하지 않는다'라기 보다, '관계형 데이터 모델로 제한하지 않는다'이다.

NoSQL이 등장하게 된 이유는 기본적으로 RDBMS의 확장성의 한계에 기인한다. RDB도 파티셔닝을 지원하긴 하지만, 태생적으로 확장 가능한 분산 환경을 사용함에 한계가 있다(일관성, 효율성).


#### 관계와 확장성
관계형 데이터 모델의 한계

관계를 지양함으로써 얻는 이점은 데이터를 분산 저장할 때 특히 두드러진다.

단순하게 트윗 모아보기의 예를 들자면, 내가 팔로잉하는 유저1의 트윗이 노드1에 있다고 가정해보자. 내가 누구를 팔로잉하는지 찾기 위해선 n개의 노드를 순회하며 모두 찾아야 할 것이고, 또 팔로잉이 작성한 트윗들을 찾기 위해서 다시 n개의 노드를 순회해야 한다(어디어디에 따르면 관계형 DB를 파티셔닝시 10배가 느려진다는 말이 있다).

반면 NoSQL은 관계 자체를 지양한다. 각각의 개별 로우로만 데이터를 구분하니 일관성 해싱(consistent hashing)과 같은 효율적인 알고리즘을 사용해 O(1)로 데이터를 곧바로 얻을 수 있고, 중첩 구조를 지원해 복잡한 구조도 저장할 수 있도록 한다. 따라서 파티셔닝(샤딩)이 용이하고 자동 샤딩또한 지원한다.

고유 특징: 쓰기/읽기 성능 특화, 2차 인덱스 지원, 자동 샤딩 지원
일반적으로 NoSQL은 관계형 데이터베이스에 비해 쓰기와 읽기 성능이 월등히 빠르다.

NoSQL은 태생적으로 관계를 지양하고 스키마가 없기 때문에 분산처리에 자유롭고 분산 환경에서 잘 동작하도록 설계되어 있다. 즉, 동일한 성격의 데이터가 물리적으로 다른 하드웨어에 저장되고 조회된다.

NoSQL에는 다음과 같은 두 가지 주요 갈래가 있다.

- 문서 데이터베이스: 데이터가 문서 자체에 포함돼 있으면서 하나의 문서와 다른 문서 간 관계가 거의 없는 사용 사례를 대상으로 한다.

- 그래프 데이터베이스: 문서 데이터베이스와는 정반대로 모든 것이 잠재적으로 관련 있다는 사용 사례를 대상으로 한다.

둘의 공통점 중 하나는 일반적으로 저장할 데이터를 위한 스키마를 강제하지 않는다는 점이며, 따라서 변화하는 요구사항에 맞춰 쉽게 애플리케이션 변경이 가능하다.

NoSQL이 필요한 경우:

* 대량의 단순 정보를 빠르게 쓰고 읽을 때
* 관계형 데이터베이스가 처리하지 못하는 대량의 데이터를 입력할 때(보통 수십 기가바이트의 데이터)
* 스키마가 고정되지 않은 데이터를 저장하고 조회할 때 등

이 있으며, 관계형 데이터베이스 특성상 제공 가능한 성능에 한계가 있다.

최근에는 관계형 DB에서도 json 데이터 타입을 지원하는 등 필드내 중첩구조를 허용하면서 점차 SQL 저장소와 NoSQL 저장소간의 경계가 모호해지고 있는 추세이다.

#### 일관성과 확장성, 성능
데이터 일관성 측면에서의 관계형 데이터 모델의 한계

MySQL과 같은 관계형 DB는 ACID의 강한 일관성을 제공한다. 이는 분산 데이터 환경에서 큰 약점이 될 수 밖에 없다.

다시 단순하게 트위터의 예를 들어 보자. 한 유저의 사용자 정보를 변경하려 했을 때, 해당 유저의 정보를 참조하는(관계가 있는) 다른 무수한 테이블과 로우들을 다른 사람들이 조회 조회하거나 변경하려 한다면? 데이터 정합성이 깨질 우려가 있다. 나아가 해당 데이터들이 n개의 노드들에 분산되어 저장돼 있다면? 데이터 정합성을 위해 해당 유저 정보를 갖고 있는 모든 노드의 모든 로우에 잠금을 해야 하고 이는 현실적이지 않을 것이다.

결국 분산에서 성능은 락과 관련이 있다. 모든 노드에 락을 걸어야하면 성능이 떨어지는 대신 일관성이 올라가고, 안걸수록 성능이 올라가고 일관성이 떨어진다.

#### 가용성

이번엔 SNS의 가장 중요한 요구사항 중 하나인 ‘가용성’을 보장하는 방법을 알아보려 한다.

가용성은 availability라고도 하고 결함 내성fault-tolerance이라고도 할 수도 있다.

availability는 기본적으로 분단 내성partition-tolerance을 전제로 한다.

보통 고가용성에 대해 논할 때 흔히 한 대 이상의 리더(마스터) 노드와 다수 대의 팔로워(또는 레플리카) 노드를 두고, 리더 노드나 네트워크에 문제가 생겼을 시 팔로워 노드를 리더 노드로 승격시켜 쓰기 작업을 할 수 있도록 한다.

읽기 요청에 대한 처리는 보다 간단하다. 한 노드에 문제가 생긴다면 다른 노드에서 읽기를 처리하면 된다.
읽기 요청은 db의 격리 수준isolation level에 따라 달라진다.
read committed, repeatable read, serialization

#### 분단 내성

가용성을 위해 전제되는 조건이 있다. 바로 분단 내성partition-tolerance이다. 분단 내성은 기본적으로 다수 개의 노드가 서로 네트워크로 연결되어 있고, 그 중 일부의 네트워크에 장애가 생기는 경우에도 시스템이 정상동작하는 능력을 뜻한다.


#### 가용성과 선형성

다만 여기에서 한 가지 트레이드 오프가 있다. 바로 선형성이다.

선형성을 보장하는 애플리케이션에서는 쓰기 작업이 모든 리더와 팔로워 노드에 동기화 되어 데이터의 일관성을 보장한다. 선형성linearization을 보장하는 애플리케이션은 모든 요청에 대한 일관성consistency 있는 응답을 보장하거나, 불가시 아예 반환하지 않는데(장애가 복구될 때 까지 기다리거나 오류 반환), 이 때 가용성availability을 포기하게 된다.

가용성availability은 모든 요청에 대한 응답을 반드시 보장한다. 단, 여기에서 트레이드 오프가 생기는데, 데이터가 최신이 아닐 수도 있다는 것이다. 즉, 선형성과 데이터의 일관성consistency를 포기한다. 다만 시간이 흐르면서 장애가 복구되거나 하여 분산 노드간 데이터는 최종적으로 일관성을 갖게 되는데 이를 최종적 일관성eventual consistency라고 한다.

네트워크가 올바르게 동작할 때는 시스템이 일관성(선형성)과 완전한 가용성 모두를 제공할 수 있다. 하지만 네트워크 장애는 일종의 결함이고 상시적이며 선택할 수 있는 것이 아니므로, 네트워크 분단이 생겼을 때 일관성consistency과 가용성availability 중 하나를 선택하라는 것이 (보다 현실적 의미의)CAP 정리이다. 참고로 현실에서 실제로 선형적인 시스템은 굉장히 드물다.

정리하자면
Consistency: 모든 시스템은 특정 순간 항상 같은 데이터를 갖는다.
Availability: 시스템에 대한 모든 요청에 항상 응답을 반환할 수 있다.
Partition Tolerance: 네트워크 분단(network partition) 등 어떤 상황에서도 시스템은 동작할 수 있다.
이다


#### ACID와 BASE
eventual consistency는 분산 환경에서 가용성을 위한 주요 성질(?) 중 하나로, 분산 환경의 BASE 원칙의 일부이기도 하다.

- Basically Available(‘기본적으로’ 가용하다는 뜻으로, 데이터는 항상 가용하되 일관성이 보장되지 않음을 뜻한다)
- Soft state: 일관성이 보장되지 않기에 상태(state)에 대해 명확히(solid) 정의할 수 없다
- Eventual Consistency: 충분한 시간이 흐를시 시스템의 모든 데이터는 최신 상태가 보장된다




























### 해결방안3 - 트위터 api의 요구사항에 맞는 저장소는 무엇일까? 어떤 저장소를 선택해야 할까?

종합하자면, 어떤 종류의 저장소를 선택해야할까? 선택지는 다음과 같다.

- 관계형 데이터베이스 vs. 비관계형 데이터베이스
    - 키-값 저장소(자료구조 저장소)
    - 문서 저장소
    - 와이드 컬럼 저장소(컬럼 패밀리 저장소)
    - 그래프 저장소
    - 비동기 메시징 저장소
- disk-based database vs. in-memory database(memcached 비교 가능. 캐싱 솔루션으론 부적합. string만 지원.)
- 탐색과 색인 지원 알고리즘: b-tree, lsm tree, skip-list, 전문 색인

### 비관계형 데이터 저장소 선택의 기준들

* 일관성 모델: 제공하는 서비스에서 어느 정도의 일관성이 필요한지, 저장소에서 어떤 일관성을 제공하는지를 말한다. 일관성 vs. 최종일관성.
* 데이터 모델: 키-값과 같이 간단한 데이터 모델로 처리 가능한지, 문서 모델과 같이 중첩 구조 지원하는지, 엄격한 스키마 정립이 필요한지, 혹은 모든 필드가 모든 관계를 맺을 수 있는지 여부 등이 있다.
* 읽기 쓰기 성능: 읽기 비율이 높을시 b-tree를 지원하는 저장소를, 쓰기 비율이 높을시 lsm tree를 지원하는 저장소를, 읽기 쓰기에 모두 성능이 필요할 시 인메모리 저장소를 고려할 수 있다.
* 단일 고장점: 단일 고장점이란 시스템을 구성하는 개별 요소 중 하나의 요소가 망가졌을 때 시스템 전체를 멈추게 만드는 요소이다. 단일 고장점을 가진 NoSQL은 자체적으로 가용성을 지원하지 못하며 별도 솔루션 함께 사용하기도 한다. 또한 단일 고장점이 있을시 쉬운 복구가 가능한지 여부도 고려할 수 있다.
    * 예를 들어 HBase 단일 고장점 있지만 장애 상황에서 하드웨어적인 방법으로 빠른 복구가 가능하다. 무정지 서비스가 중요 목표라면 단일 고장점 NoSQL은 되도록 피해야 한다.
* 원자성 지원: 트랜잭션 지원 여부, 단일 연산에 대한 원자성 지원 여부
등을 고려할 수 있다. 원자성 지원이 어느 쪽(서버, 클라이언트)에서 지원되는지 확인 요소가 되며, 클라이언트에서 지원하는 단일 연산 원자성은 코드 복잡성 증가시킬 수 있다.
* 하드웨어 구성
* 무중단 시스템: 시스템 확장시 중단이 필요한지 여부와 같은 시스템의 특성 확인해야 한다. 
    * eg. MongoDB는 자동 샤딩을 지원하며, 운영중 시스템 추가가 가능하다. 단, 자동 샤딩 중 서비스 응답시간 느려지기도 한다.






<br>

---
# 선택과 결정1


## 스케일 아웃

트윗의 경우 단일 요청에 대한 연산이 단순한 반면 개별 요청의 빈도가 높다. 이런 경우 스케일 아웃과 더불어 로드밸런싱으로 부하 분산이 가능하며, SNS의 가장 핵심 요구사항인 가용성을 보장하기 위해서 데이터 분산이 반드시 필요하다. 또한 트래픽 증가에 따른 지속적인 확장은 수직확장으로는 한계가 있으며, 수평확장이 트래픽 증가에 대처하기 용이하다. 



## 일관성과의 합의

- tweet은 강한 일관성이 별로 필요 없다. 결제 시스템에서는 클라이언트간 데이터가 다를시 큰 문제로 이어질 수 있지만, 트위터의 핵심 기능인 모아보기 등에서 사람들은 다른 사람의 트윗이 몇 초 다르게 보이더라도 유저는 크게 거부감이 없을 것이다. 그보단 요청에 대한 낮은 지연시간과 높은 가용성이 우선이라고 생각하였다.



## 데이터 저장소 선택

- pull과 push의 혼합 방식을 구현하기 위해 관계형 데이터 저장소로써 MySQL을, 비관계형 데이터 저장소로써 Redis를 선택하였다. 
    - 관계형 데이터 저장소로 MySQL을 선택한 이유는 다음과 같다
        - 오픈소스이며, Java 애플리케이션 자체 API를 제공한다.
        - 클러스터링과 자동 샤딩을 제공한다.
            - 샤딩시 데이터 일자별로 샤딩이 가능해 쓰기 부하를 줄일 수 있다.
    - 비관계형 데이터 저장소로 Redis를 선택한 이유는 다음과 같다(레디스에 대해 보다 많은 조사 필요).
        - 그래프 형식과 와이드 컬럼 형식의 저장소는 트위터의 모아보기 api와 크게 해당이 없을 것이라고 생각하여 배제하였다. 와이드 컬럼 저장소의 경우 데이터 분석에 초점이 맞춰져 있고, 카산드라의 경우 lsm tree를 활용해 읽기보다 쓰기에 성능 초점이 맞춰져 있으며, 타임라인 모아보기는 많은 컬럼을 필요로 하지 않는다. 또한 타임라인의 로우들이 다른 테이블의 로우들과의 관계성도 한계가 있기에 그래프 저장소도 배제하였다.
        - 일관성 모델: 레디스 클러스터 조사-결과적 일관성 제공으로 작성
        - 데이터 모델: 레디스는 키-값 구조의 데이터 모델을 제공하며, 값으로 리스트, 정렬된 셋 등 다양한 자료구조를 제공한다. 특히 리스트나 정렬된 셋 등의 자료구조는 트위터를 fan-out할 시 유저 개개인의 타임라인을 저장하기에도 적합하다고 판단하였다.
        - 읽기 쓰기 성능: 트위터의 경우 읽기와 쓰기 양쪽 모두에서 높은 성능을 요구하므로 인메모리 데이터베이스를 고려하였다. 타임라인의 fan-out구현에 있어서 유저의 읽기, 쓰기 모두에서 값의 자료구조 선택에 O(1)에서 O(logN)의 저렴한 비용으로 수행 가능하다. 관계형 DB와 혼합해 사용하므로 영속성의 요건 또한 갖춤과 동시에 성능의 이점 또한 얻을 수 있다.
        - 단일 고장점: 레디스는 센티넬과 클러스터라는 고가용성을 지원하여, 리더 노드에 문제가 생길시 즉시 대처가 가능하다. 또한 클러스터로 다중 리더 시스템을 구축하여 단일 고장점 자체를 없앨 수 있다. 일관성 해싱을 지원해 효율적인 분산이 가능하다.
        - 원자성 지원: 레디스는 클라이언트(Java 애플리케이션)와 서버 모두에서 트랜잭션을 지원하지만, 중간에 장애가 생길시 연산 전체의 원자성을 보장하지는 않아 fan-out시 데이터의 정합성에 문제가 있을 수 있다. 이 문제는 비동기 메시징 시스템으로 해결하려고 하였으며, 다음 포스팅에서 다루기로 하겠다.
        - 무중단 시스템: 레디스 클러스터는 자동 샤딩을 지원하여 시스템 확장시 중단이 필요 없다.(추가 조사 필요)
        



### 선택

스케일 아웃 방식을 택했고 일관성을 일부 합의하였으며, 저장소로 MySQL과 Redis를 선택하였다.

(데이터가 적거나 요청량이 적을 때, 증가량을 사전에 예측할 수 있을 때는 일반 RDBMS를 사용해도 문제가 없겠지만, 데이터 증가량을 측정하기 어렵거나, 서비스 요청량 증가를 예측하기 어려운 상황에서는 NoSQL 저장소가 더 적합할 수 있다고 생각했다.)








<br><br><br><br><br><br><br><br>

---
# 요구사항2 - 고가용성의 제약조건과 트레이드오프
## 요구사항 분석
### 장애가 생긴 경우에도 어떻게 가용성을 보장할 수 있을까?

가용성: 무슨 일이 있어도 데이터는 항상 가용해야 한다. ‘모든 클라이언트의 읽기와 쓰기 요청에 대하여 항상 응답이 가능해야 함을 보증하는 것.’ 전편에서 언급됐듯이, SNS에서 가용성은 가장 민감한 이슈이다. 장애에 빠르게 복구가 불가하다면 이는 곧 사용자 이탈로 이어질 수 있다. 데이터를 분산하여 SPOF를 줄이는 것이 중요하다.

일관성, 정합성: 데이터에 대한 일관성 요구는 비교적 덜할 수 있다. 예를 들어 계좌 이체 서비스에서 아주 잠깐이라도 계좌의 잔고가 다르게 조회된다면 치명적인 문제를 야기할 수 있다. 하지만 트위터의 경우 일시적으로 사용자간 데이터가 다르게 표시된다고 한들 큰 문제가 발생하지는 않고 사용자들이 그렇게 요구하지도 않는다.

유연성 필요: 유저 베이스가 큰 만큼 트래픽도 편차가 심할 수 있고 유연성이 필요할 수 있다. 어떨 땐 사용자 수가 폭발적으로 늘어나거나 심하게 쏠림현상이 생길 수도 있다. 예를 들어 주말 오후나 저녁 시간대에는 트래픽이 많이 쏠리고, 평일 오전 오후에는 트래픽이 훨씬 적을 수 있다.

데이터 특성: 개별 요청의 빈도는 크지만, 각각의 요청에 요구되는 연산은 비교적 매우 단순하다.

글로벌: 트위터는 글로벌 서비스이고, 더 낮은 지연시간을 위해 세계 각 지역에 각각의 데이터 센터를 구축해 관리할 필요가 있다. 따라서 분산 환경이 더 적합하고 효율적일 수있다.

* 이를 보아 스케일업보다 스케일아웃을 선택함이 매우 타당하다고 볼 수 있다.





<br>

## 해결 방안
### 해결방안

- 어떻게 성능과 확장성, 가용성을 도모할까?

    - 복제 VS 파티셔닝

	- 레디스 센티넬 vs. 클러스터(for scale)


<br>

---
# 선택과 결정2



<br><br><br><br><br><br><br><br><br>

---
# 구현








<br><br><br><br><br><br><br><br><br>

---

# reference











---
- mongodb, redis, cassandra, graph

cost: 응답시간latency

동기식-선형성 vs. 비동기식
일관성 vs 최종 일관성

Redis
AOF(append only file, RDB)

