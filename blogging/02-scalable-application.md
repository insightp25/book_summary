[02.v.04] 본문

확장성 있는 고가용성 분산 시스템의  제약 조건과 트레이드오프(feat. 데이터 모델, 저장소, 색인)

저장 기술은 무엇을 선택할까? 확장에 유연하고 결함에 강한 분산 데이터 시스템 구축하기
확장성있는 고가용성 분산 시스템의 제약 조건과 트레이드오프(feat. 데이터 모델, 저장소, 색인)
부하 증가에 대처하는 확장과 고가용성, 그를 따르는 제약조건과 트레이드오프

# 서문

지난 글에서 SNS의 핵심 요구사항으로 반응성(낮은 지연시간)과 가용성을 꼽았고, 대규모 트래픽과 읽기 집중에서 더 나은 반응성을 위한 알고리즘에 대해 생각해 보았다. 다만 해당 알고리즘은 기본적으로 관계형 DB를 사용하며, 트래픽이 증가하지 않는 상황을 전제로 하였다.

이번 포스팅에서는 
* 트래픽이 늘어 부하가 증가하는 상황에서 낮은 지연시간을 계속 보장하는 방법,
* 네트워크나 노드에 장애가 생기는 경우 데이터의 가용성을 보장하는 방법,
* 고가용성의 제약조건과 트레이드오프,
* 애플리케이션 요구사항에 적합한 저장소 선택의 기준

에 대해 알아보며, 트위터 API에 적합한 데이터 저장소 선택 과정과 데이터 시스템 디자인에 대해 소개하고자 한다.

<br><br><br><br><br><br><br>

---
# 요구사항 1 - 대용량 데이터와 부하 증가에서 성능 보장

## 점점 빨라지는 서비스 성장 추세와 대용량 데이터 처리

모든 신규 서비스들은 성장과 확장을 기본 전제로 할 것이다. 다만 그 추세가 점점 빨라지고 있다. 
* 트위터는 2013년 초당 4,000회 쓰기 요청에서 2023년 초당 6,000회 쓰기 요청으로 10년간 약 50%의 트래픽이 증가하였다. 
* OpenAI의 ‘ChatGPT’ 서비스는 런칭한지 2개월만에 가입자 1억 명을 돌파했고, 
* 메타의 신규 서비스 ’Threads’는 ChatGPT의 기록을 깨고 불과 5일만에 가입자 1억명을 달성하였다.

그렇다면 트래픽과 부하 증가를 예측하기 어려운 상황에서 어떻게 애플리케이션을 디자인해야할까? 또한 대규모 트래픽에서도 어떻게 지속적인 데이터의 가용성을 보장하며, 그에 따르는 제약조건과 트레이드오프는 무엇일까?



## 트위터 API의 요구사항의 특징

트위터의 타임라인(모아보기) 읽기, 트윗 쓰기 등 개별 요청에 요구되는 연산은 단순하다. 하지만 초당 요청 횟수가 많아 부하가 발생하는 형태이다. 

<br>

## 문제 정의

> 급격한 부하 증가의 상황에서 어떻게 5초 이내의 지연시간을 계속해 보장할 수 있을까?


<br>

## 해결 방안 - 스케일 업 vs. 스케일 아웃

문제 해결을 위한 방법으로 서버 확장이 있을 것이다. 서버 확장의 방법과 그에 따르는 제약상황, 트레이드오프에 무엇이 있는지 알아보자.

### 스케일업

스케일업은 수직확장이라고도 하며, 단일 서버(하드웨어)의 성능을 증가시켜서 더 많은 요청을 처리하는 방법이다. 단일 하드웨어의 성능을 높이기 위해 CPU, 메모리, 하드디스크를 업그레이드 하거나 추가하는 것이다. 

이점

1. 단순성: 확장이 기술적으로는 복잡하지 않다. 단순히 CPU나 RAM, 저장소를 추가하기만 하면 된다.
2. 호환성: 애플리케이션이 분산 환경을 감안하지 않아도 된다.
3. 성능: 집중 연산 능력을 요구하는 일부 작업에 효과적이며, 모든 자원들이 한 하드웨어 내에서 모두 연결돼있으므로 지연이 보다 낮을 수 있다.

트레이드오프

1. 비용: 하드웨어의 성능이 높아질 수록 비용 대비 개선 효과가 줄어들며 비싸다.
2. 물리적 제약: 아무리 좋은 하드웨어와 고사양 부품이 있다고 하더라도 단일 장비에 설치할 수 있는 슬롯에 한계가 있다.
3. 단일 고장점(SPOF, Single Point of Failure): 장애에 취약하다. 만약 고사양의 서버에 장애가 생기면 그만큼 타격이 클 수 밖에 없다.
4. 확장 편의성: 중간에 부하가 늘어나 추가로 확장하기 위해선 스케일업 과정중 백업할 비슷한 사양의 1회성 서버가 한 대가 더 필요하고 불필요한 비용이 발생하게 된다. 또한 늘어나는 속도를 예측하지 못할시 중간에 서버를 중단시켜야 할 수 있고, 기존 서버 데이터를 옮기고 데이터를 정리하려면 그 작업 시간만큼 서비스가 중단될 것이다. 이 작업은 적게는 수 시간에서 많게는 하루 이상이 걸릴 수 있는데, 사용자가 늘어날 때마다 이런 작업을 반복할 수는 없을 것이다.


### 스케일 아웃

스케일아웃은 수평확장이라고도 하며, 동일 사양의 새로운 서버(하드웨어)를 추가하는 방법이다.

이점

1. 유연성: 필요에 따라 장비를 추가하거나 줄일 수 있어 비용효과적이다.
2. 가용성(내결함성): 고가용성을 제공할 수 있고 데이터 분산을 통해 특정 장비의 결함에 보다 견고하다.
3. 확장성: 기본적으로 얼마나 확장할지에 대한 상한이 없으며 계속 노드를 추가할 수 있다.
4. 로드밸런싱: 로드밸런싱을 통해 부하를 고르게 분산시킬 수 있다.

트레이드오프

1. 복잡성: 분산을 위해 더 복잡한 시스템 아키텍처가 필요하며, 소프트웨어가 분산 환경에서 동작할 수 있어야 한다.
2. 관리: 노드가 늘어날 수록 노드를 관리할 수 있는 시스템이 더 많이 필요하게 되며, 운영에 필요한 부하와 복잡성이 증가한다.
3. 네트워크 의존성: 노드간 네트워크 장애나 지연에 취약하다
4. 비일관성inconsistency: 노드간 데이터 일관성과 동기화 이슈가 있을 수 있다.




# 선택과 결정

트위터의 타임라인(모아보기) 읽기, 트윗 쓰기 등 개별 요청에 요구되는 연산은 단순하다. 하지만 초당 요청 횟수가 많아 부하가 발생하는 형태이다. 또한 트래픽이 지속적으로 증가하며 예측할 수 없다.

이런 상황에서는 한 노드에 연산 능력을 성능을 집중하는 것보다, 여러 노드에 데이터를 분산시키고 로드밸런싱을 통해 부하를 고르게 분산할 수 있는 스케일 아웃이 적합하다고 판단하였다.

또한 스케일 아웃이 적합한 중요한 이유가 더 있는데, 바로 다음에서 다룰 가용성의 문제이다이다.

<br>
<br>
<br>
<br>
<br>
<br>
<br>


# 요구사항 2 - 장애 상황에 견고한 데이터 시스템


## 트위터 API의 요구사항의 특징

서버의 수평 확장과 가용성, 데이터 분산 측면에서 트위터 API와 관련된 사항들은 아래와 같다.

* 가용성: 여기에서 가용성이란 ‘모든 클라이언트의 읽기와 쓰기 요청에 대하여 항상 응답이 가능해야 함을 보증하는 것’을 의미한다. 전 포스팅에서 언급했듯, SNS에서 가용성은 가장 민감한 이슈이다. 장애에 빠르게 복구가 불가하다면 이는 곧 사용자 이탈로 이어질 수 있기 때문이다.
장비의 결함이나 네트워크의 장애는 일상적으로 일어나는 통제 범위 밖의 영역이다. 따라서 장애 상황을 가정하고 수평 확장과 노드간의 느슨한 결합을 통해 데이터를 분산하고 단일 고장점을(SPOF, single point of failure)를 줄이는 것이 현실적이다.
보통 고가용성에 대해 논할 때엔 한 대 이상의 리더(마스터) 노드와 한 리더당 한 대 이상의 팔로워(또는 레플리카) 노드를 두며, 리더 노드나 네트워크에 문제가 생겼을 시 팔로워 노드를 리더 노드로 승격시켜 쓰기 작업을 할 수 있도록 한다. 읽기 요청은 주로 팔로워 노드에서 처리한다. 

* 일관성(선형성): 여기에서 일관성이란, 일정 시점에서 여러 노드에서 데이터가 동일함을 보장한 것을 의미한다. 데이터에 대한 일관성 요구는 비교적 덜할 수 있다. 예를 들어 계좌 이체 서비스에서 아주 잠깐이라도 계좌의 잔고가 다르게 조회된다면 치명적인 문제를 야기할 수 있다. 하지만 트위터의 경우 일시적으로 사용자간 데이터가 다르게 표시된다고 한들 큰 문제가 발생하지 않으며 사용자들 또한 엄격한 일관성을 요구하지도 않는다.

* 글로벌: 트위터는 글로벌 서비스이고, 더 낮은 지연시간을 위해 세계 각 지역에 각각의 데이터 센터를 구축해 관리할 필요가 있다. 따라서 분산 환경이 더 적합하고 효율적일 수있다.

## 문제 정의

> 어떻게 데이터의 상시 가용성을 보장할 수 있을까?

## 데이터 분산의 제약조건과 트레이드오프

스케일 아웃은 곧 여러 노드로의 데이터 분산을 의미한다. 데이터 분산에는 크게 복제와 파티셔닝이 있다. 복제는 크게 두 가지 이점이 있다. 첫째로는 데이터를 여러 노드에 복제함으로써 부하를 분산시키고 성능을 개선할 수 있고, 둘째로 한 노드가 장애로 단절된다고 하여도 다른 노드에서 데이터를 다룰 수 있다.

분산 시스템에 대해 논의하기 전에 다음의 세 가지 주요 개념에 대해 알아야 한다.

* 일관성Consistency: 모든 시스템은 특정 순간 항상 동일한(일관된) 데이터를 갖는다.
* 가용성Availability: 시스템에 대한 모든 요청에 항상 응답을 반환할 수 있다.
* 분단 내성Partition-tolerance: 네트워크 분단(network partition) 등 어떤 상황에서도 시스템은 동작할 수 있다.

분산 시스템에서 네트워크가 올바르게 동작할 때는 시스템이 일관성(선형성)과 완전한 가용성 모두를 제공할 수 있다. 하지만 네트워크 장애는 일종의 결함이고 상시적이며 선택할 수 있는 것이 아니므로, 네트워크 분단이 생겼을 때 일관성consistency과 가용성availability 중 하나를 선택할 수 밖에 없다(원래 CAP 정리는 '일관성consistency과 가용성availability, 분단 내성partition-tolerance 중 2가지를 고르라'는 내용이지만, 현실에서 네트워크의 분단은 선택 사항이 아니다).

선형성linearization을 구현하는 애플리케이션에서는 쓰기 작업이 모든 리더와 팔로워 노드에 동기화 되어 특정 순간 항상 동일한 데이터를 가지며 일관성을 보장한다. 선형성을 보장하는 애플리케이션은 모든 요청에 대한 일관성 있는 응답을 보장하거나, 불가시 아예 반환하지 않는데(장애가 복구될 때 까지 기다리거나 오류 반환), 이 때 가용성availability을 포기하게 되며, 시스템 전체의 성능이라는 큰 비용을 지불해야 한다. 또한 구조상 전체 시스템이 일관성을 보장해야 하기에 한 노드의 결함에도 전체 시스템이 취약해질 수 밖에 없다.

가용성(availability 또는 결함내성fault-tolerance)을 보장하는 시스템에서는 모든 요청에 대한 응답을 반드시 보장한다. 네트워크 분단 상황에서 일관성이 아닌 가용성을 택할시 트레이드 오프가 발생하는데, 데이터가 최신이 아닐 수도 있다는 것이다. 즉, 데이터의 일관성consistency를 포기한다. 다만 시간이 흐르면서 장애가 복구되거나 하여 분산 노드간 데이터는 최종적으로 일관성을 갖게 되는데 이를 최종적 일관성eventual consistency라고 한다.

#### ACID와 BASE
기본적으로 현실의 분산 시스템에서 성능과 결함에 대한 취약성을 이유로 선형성을 구현하는 애플리케이션은 드물며 대부분의 분산 시스템이 가용성을 택한다. 가용성을 제공하는 분산 시스템의 데이터와 관련한 특징은 흔히 'BASE'로 정리되기도 한다.

- Basically Available: ‘기본적으로’ 가용하다는 뜻으로, 데이터는 항상 가용하되 일관성이 보장되지 않음을 뜻한다.
- Soft state: 일관성이 보장되지 않기에 특정 시점의 상태(state)에 대해 명확히(solid) 정의할 수 없다.
- Eventual Consistency: 충분한 시간이 흐를시 시스템의 모든 데이터는 최신 상태가 보장된다.

BASE의 반대 개념으로 'ACID'를 꼽기도 하는데, 이는 다음 포스팅에서 분산 트랜잭션에 관해 다룰 때 함께 알아보고자 한다.













<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

---
# 요구사항 3 - 트위터 API에 적합한 저장소 선택

지난 포스팅의 알고리즘 고안시 관계형 DB를 기준으로 삼았었다. 하지만 과연 관계형 DB가 트위터의 api에 최적일까? 다른 선택지에는 어떤 것들이 있으며, 어떤 점을 기준으로 살펴봐야 할까?

## 트위터 API의 요구사항의 특징

저장소 선택에 있어 성능 측면에서는 지난 포스팅에서 알아본 대로 읽기 집중으로 인해 압도적인 읽기 성능이 절대으로 요구되며, fan-out을 위한 강력한 쓰기 성능 또한 필요하다.

SNS 특성상 가용성과 데이터 분산 또한 필수적이므로, 자동 복제 및 샤딩 등 저장소 서버 차원에서의 자체적 클러스터링 솔루션 제공여부도 고려사항이 될 수 있다. 또한 분산 확장에 용이한 데이터 모델을 제공할 수 있어야 한다.

또한 비정형 데이터를 다룰 수 있어야 한다. 트위터 핵심 기능인 타임라인의 경우 fan-out 방식 구현시 데이터가 비정형적이다. 지난 포스팅의 내용처럼 fan-out을 할 경우 경우 각 유저마다 타임라인을 구성해야 한다. 즉, 유저별로 타임라인이라는 데이터를 저장하게 될 것이고, 모든 유저의 타임라인은 형태가 다를 것이며 또 수시로 변할 것이다.

<br>

## 문제 정의

> 1. 읽기와 쓰기 모두 강력한 성능을 제공하는 데이터 저장소에는 무엇이 있을까?
2. 복제와 샤딩 등 확장을 제공하는 데이터 저장소에는 무엇이 있을까?
3. 비정형 데이터를 효과적으로 처리할 수 있는 데이터 저장소에는 무엇이 있을까?


<br>

## 데이터 저장소의 발전 과정과 데이터 모델

역사적으로 데이터를 하나의 큰 트리(계층 모델)로 표현하려고 노력했지만 다대다 관계를 표현하기에는 트리 구조가 적절하지 않았다. 이 문제를 해결하기 위해 관계형 모델이 고안됐다. 하지만 개발자들은 관계형 모델에도 적합하지 않은 애플리케이션이 있다는 사실을 발견했다. 또한 상상조차 불가능한 양의 데이터, 그리고 비정형 데이터가 포함된 데이터를 분산해 저장하고 사용하는 방법을 연구하며 NoSQL(비관계형 데이터 저장소)이라고 불리우는 새로운 데이터 저장소 유형이 등장하였다.

NoSQL의 정의에 대해 명확히 합의된 바는 없지만, 대표적으로 마틴파울러의 정의에 따르면 다음과 같다.

- 대용량 웹 서비스를 위해 만들어진 데이터 저장소
- 관계형 데이터 모델을 지양하며 대량의 데이터를 저장하고 조회하는 데 특화된 저장소
- 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소

핵심은 '관계형 데이터 모델을 사용하지 않는다'라기 보다, '관계형 데이터 모델로 제한하지 않는다'이다.

NoSQL이 등장하게 된 이유는 근본적으로 RDBMS의 확장성의 한계에 기인한다. RDB도 파티셔닝을 지원하긴 하지만, 태생적으로 확장 가능한 분산 환경을 제공함에 한계가 있다.


## 트위터 API와 관계형 데이터 모델의 한계

관계를 지양함으로써 얻는 이점은 데이터를 분산 저장할 때 특히 두드러진다.

단순하게 트윗 모아보기의 예를 들자면, 내가 팔로잉하는 유저1의 트윗이 노드1에 있다고 가정해보자. 내가 누구를 팔로잉하는지 찾기 위해선 n개의 노드를 순회하며 모두 찾아야 할 것이고, 또 팔로잉이 작성한 트윗들을 찾기 위해서 다시 n개의 노드를 순회해야 한다(어디어디에 따르면 관계형 DB를 파티셔닝시 10배가 느려진다는 말이 있다).

반면 NoSQL은 관계 자체를 지양한다. 스키마가 없기 때문에 분산처리에 자유롭고 분산 환경에서 잘 동작하도록 설계되어 있다. 즉, 동일한 성격의 데이터가 물리적으로 다른 하드웨어에 저장되고 조회된다. 각각의 개별 로우로만 데이터를 구분하니 일관성 해싱(consistent hashing)과 같은 효율적인 알고리즘을 사용해 O(1)로 데이터를 곧바로 얻을 수 있고, 중첩 구조를 지원해 복잡한 구조도 저장할 수 있도록 한다. 따라서 파티셔닝(샤딩)이 용이하고 자동 샤딩또한 지원한다.

NoSQL은 쓰기/읽기 성능 특화, 2차 인덱스 지원, 자동 샤딩 지원와 같은 공통적인 특징이 있으며, 일반적으로 관계형 데이터베이스에 비해 읽기 또는 쓰기 성능이 월등히 빠르다.

NoSQL에는 다음과 같은 두 가지 주요 갈래가 있다.

- 문서 데이터베이스: 데이터가 문서 자체에 포함돼 있으면서 하나의 문서와 다른 문서 간 관계가 거의 없는 사용 사례를 대상으로 한다.

- 그래프 데이터베이스: 문서 데이터베이스와는 정반대로 모든 것이 잠재적으로 관련 있다는 사용 사례를 대상으로 한다.

둘의 공통점 중 하나는 일반적으로 저장할 데이터를 위한 스키마를 강제하지 않는다는 점이며, 따라서 변화하는 요구사항에 맞춰 쉽게 애플리케이션 변경이 가능하다.

## 비관계형 데이터 저장소가 필요한 경우

비관계형 데이터 저장소가 필요한 경우는 대표적으로 다음과 같다.

* 대량의 단순 정보를 빠르게 쓰고 읽을 때
* 관계형 데이터베이스가 처리하지 못하는 대량(보통 수십 기가바이트)의 데이터를 입력할 때
* 스키마가 고정되지 않은 데이터를 저장하고 조회할 때

관계형 데이터베이스 특성상 제공 가능한 성능에는 한계가 있다.

최근에는 관계형 DB에서도 json 데이터 타입을 지원하는 등 필드내 중첩구조를 허용하면서 점차 SQL 저장소와 NoSQL 저장소간의 경계가 모호해지고 있는 추세이다.


## 확장성 측면에서의 관계형 데이터 모델의 한계

MySQL과 같은 관계형 DB는 ACID의 강한 일관성을 제공한다. 이는 분산 데이터 환경에서는 되려 취약점이 된다.

다시 단순하게 트위터의 예를 들어 보자. 한 유저의 사용자 정보를 변경하려 했을 때, 해당 유저의 정보를 참조하는(관계가 있는) 다른 무수한 테이블과 로우들을 다른 사람들이 조회 조회하거나 변경하려 한다면? 데이터 정합성이 깨질 우려가 있다. 나아가 해당 데이터들이 n개의 노드들에 분산되어 저장돼 있다면? 데이터 정합성을 위해선 해당 유저 정보를 갖고 있는 모든 노드의 모든 로우에 잠금을 해야 하고 이는 현실적이지 않을 것이다.

모든 노드에 락을 걸어야하면 일관성을 확보할 수 있겠지만, 성능을 희생해야하며, 네트워크 장애 등 결함에 더욱 취약해질 수 밖에 없다.

<br>
<br>

## 데이터 저장소의 주요 선택 기준들

어떤 종류의 저장소를 선택해야할까? 선택지는 다음과 같다.

- 데이터 모델에 따른 분류
	- 관계형 데이터 베이스
    - 키-값 저장소(자료구조 저장소)
    - 문서 저장소
    - 와이드 컬럼 저장소(컬럼 패밀리 저장소)
    - 그래프 저장소
- disk-based database vs. in-memory database(memcached 비교 가능. 캐싱 솔루션으론 부적합. string만 지원.)
- 동기식 vs. 비동기식
- 탐색과 색인 알고리즘: b-tree, lsm tree, skip-list, 전문 색인 등

## 비관계형 데이터 저장소 선택의 기준들

* 일관성 모델: 제공하는 서비스에서 어느 정도의 일관성이 필요한지, 저장소에서 어떤 일관성을 제공하는지를 말한다(일관성 vs. 최종적 일관성).
* 데이터 모델: 키-값과 같이 간단한 데이터 모델로 처리 가능한지, 문서 모델과 같이 중첩 구조 지원하는지, 엄격한 스키마 정립이 필요한지, 혹은 모든 필드가 모든 관계를 맺을 수 있는지 여부 등이 있다.
* 읽기 쓰기 성능: 읽기 비율이 높을시 b-tree를 지원하는 저장소를, 쓰기 비율이 높을시 lsm tree를 지원하는 저장소를, 읽기 쓰기에 모두 성능이 필요할 시 인메모리 저장소를 고려할 수 있다.
* 단일 고장점: 단일 고장점이란 시스템을 구성하는 개별 요소 중 하나의 요소가 망가졌을 때 시스템 전체를 멈추게 만드는 요소이다. 단일 고장점을 가진 저장소는 자체적으로 가용성을 지원하지 못하며 별도 솔루션 함께 사용하기도 한다. 또한 단일 고장점이 있을시 쉬운 복구가 가능한지 여부도 고려할 수 있다. 무정지 서비스가 중요 목표라면 단일 고장점 저장소는 되도록 피해야 한다.
    * 예를 들어 HBase의 경우 단일 고장점 있지만 장애 상황에서 하드웨어적인 방법으로 빠른 복구가 가능하다.
* 원자성 지원: 트랜잭션 지원 여부, 단일 연산에 대한 원자성 지원 여부 등을 고려할 수 있다. 원자성 지원이 어느 쪽(서버, 클라이언트)에서 지원되는지 확인 요소가 되며, 클라이언트에서 지원하는 단일 연산 원자성은 코드 복잡성 증가시킬 수 있다.
* 하드웨어 구성
* 무중단 시스템: 시스템 확장시 중단이 필요한지 여부와 같은 시스템의 특성 확인해야 한다. 
    * eg. MongoDB는 자동 샤딩을 지원하며, 운영중 시스템 추가가 가능하다. 단, 자동 샤딩 중 서비스 응답시간 느려지기도 한다.






<br>

---
# 선택과 결정


스케일 아웃 방식을 택했고 일관성을 일부 합의하였으며, 저장소로 MySQL과 Redis를 선택하였다.

(데이터가 적거나 요청량이 적을 때, 증가량을 사전에 예측할 수 있을 때는 일반 RDBMS를 사용해도 문제가 없겠지만, 데이터 증가량을 측정하기 어렵거나, 서비스 요청량 증가를 예측하기 어려운 상황에서는 NoSQL 저장소가 더 적합할 수 있다고 생각했다.)

## 스케일 아웃

트윗의 경우 단일 요청에 대한 연산이 단순한 반면 개별 요청의 빈도가 높다. 이런 경우 스케일 아웃과 더불어 로드밸런싱으로 부하 분산이 가능하며, SNS의 가장 핵심 요구사항인 가용성을 보장하기 위해서 데이터 분산이 반드시 필요하다. 또한 트래픽 증가에 따른 지속적인 확장은 수직확장으로는 한계가 있으며, 수평확장이 트래픽 증가에 대처하기 용이하다. 



## 일관성과 가용성 사이에서의 선택

- 트위터의 핵심 기능인 모아보기 등에서 사람들은 다른 사람의 트윗이 몇 초 다르게 보이더라도 유저는 크게 거부감이 없을 것이다. 그보단 요청에 대한 낮은 지연시간과 높은 가용성이 우선이라고 생각하였다.



## 데이터 저장소 선택

- pull과 push의 혼합 방식을 구현하기 위해 관계형 데이터 저장소로써 MySQL을, 비관계형 데이터 저장소로써 Redis를 선택하였다. 
    - 관계형 데이터 저장소로 MySQL을 선택한 이유는 다음과 같다
        - 오픈소스이며, Java 애플리케이션 자체 API를 제공한다.
        - 클러스터링과 자동 샤딩을 제공한다.
            - 샤딩시 데이터 일자별로 샤딩이 가능해 쓰기 부하를 줄일 수 있다.
    - 비관계형 데이터 저장소로 Redis를 선택한 이유는 다음과 같다(레디스에 대해 보다 많은 조사 필요).
        - 그래프 형식과 와이드 컬럼 형식의 저장소는 트위터의 모아보기 api와 크게 해당이 없을 것이라고 생각하여 배제하였다. 와이드 컬럼 저장소의 경우 데이터 분석에 초점이 맞춰져 있고, 카산드라의 경우 lsm tree를 활용해 읽기보다 쓰기에 성능 초점이 맞춰져 있으며, 타임라인 모아보기는 많은 컬럼을 필요로 하지 않는다. 또한 타임라인의 로우들이 다른 테이블의 로우들과의 관계성도 한계가 있기에 그래프 저장소도 배제하였다.
        - 일관성 모델: 레디스 클러스터 조사-결과적 일관성 제공으로 작성
        - 데이터 모델: 레디스는 키-값 구조의 데이터 모델을 제공하며, 값으로 리스트, 정렬된 셋 등 다양한 자료구조를 제공한다. 특히 리스트나 정렬된 셋 등의 자료구조는 트위터를 fan-out할 시 유저 개개인의 타임라인을 저장하기에도 적합하다고 판단하였다.
        - 읽기 쓰기 성능: 트위터의 경우 읽기와 쓰기 양쪽 모두에서 높은 성능을 요구하므로 인메모리 데이터베이스를 고려하였다. 타임라인의 fan-out구현에 있어서 유저의 읽기, 쓰기 모두에서 값의 자료구조 선택에 O(1)에서 O(logN)의 저렴한 비용으로 수행 가능하다. 관계형 DB와 혼합해 사용하므로 영속성의 요건 또한 갖춤과 동시에 성능의 이점 또한 얻을 수 있다.
        - 단일 고장점: 레디스는 센티넬과 클러스터라는 고가용성을 지원하여, 리더 노드에 문제가 생길시 즉시 대처가 가능하다. 또한 클러스터로 다중 리더 시스템을 구축하여 단일 고장점 자체를 없앨 수 있다. 일관성 해싱을 지원해 효율적인 분산이 가능하다.
        - 원자성 지원: 레디스는 클라이언트(Java 애플리케이션)와 서버 모두에서 트랜잭션을 지원하지만, 중간에 장애가 생길시 연산 전체의 원자성을 보장하지는 않아 fan-out시 데이터의 정합성에 문제가 있을 수 있다. 이 문제는 비동기 메시징 시스템으로 해결하려고 하였으며, 다음 포스팅에서 다루기로 하겠다.
        - 무중단 시스템: 레디스 클러스터는 자동 샤딩을 지원하여 시스템 확장시 중단이 필요 없다.(추가 조사 필요)
        


## 레디스 센티넬, 클러스터 제공










<br><br><br><br><br><br><br><br>

---





<br>

## 해결 방안
### 해결방안



<br>




<br><br><br><br><br><br><br><br><br>

---
# 구현








<br><br><br><br><br><br><br><br><br>

---

# reference











---
- mongodb, redis, cassandra, graph

cost: 응답시간latency

동기식-선형성 vs. 비동기식
일관성 vs 최종 일관성

Redis
AOF(append only file, RDB)





---
* 유연성 필요: 유저 베이스가 큰 만큼 트래픽도 편차가 심할 수 있고 유연성이 필요할 수 있다. 어떨 땐 사용자 수가 폭발적으로 늘어나거나 심하게 쏠림현상이 생길 수도 있다. 예를 들어 주말 오후나 저녁 시간대에는 트래픽이 많이 쏠리고, 평일 오전 오후에는 트래픽이 훨씬 적을 수 있다.




---
읽기 요청은 db의 격리 수준isolation level에 따라 달라진다.
read committed, repeatable read, serialization
