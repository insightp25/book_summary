[02.v.03] 본문

분산 처리, 확장성, 가용성, 저장소를 선택하는 기준들

서문


확장성의 필요성

모든 신규 서비스들은 성장과 확장을 기본 전제로 할 것이다. 트위터는 2013년 초당 4,000회 쓰기 요청에서 2023년 초당 6,000회 쓰기 요청으로 약 50%의 트래픽이 증가하였다. OpenAI의 ‘ChatGPT’ 서비스는 런칭한지 2개월만에 가입자 1억 명을 달성했고, 메타의 신규 서비스 ’스레드’는 ChatGPT의 기록을 깨고 불과 5일만에 가입자 1억명을 달성하였다.

이전 포스팅에서 살펴보았듯, 대규모 트래픽을 처리하는 애플리케이션 구현 방법은 서비스의 세부 요구사항에 따라 달라질 수 있을 것이다. 그렇다면 지난 트위터의 애플리케이션 구현에 어떤 저장소를 도입해야 할까?(애플리케이션에 최적의 저장소는 어떻게 선택해야할까?) 이번에는 대용량 데이터를 처리하고 확장한 용이한 서비스를 위해 알맞은 데이터 저장소를 선택하는 기준에 어떤 것들이 있는지, 대용량 데이터를 다루는 저장소의 선택기준과 방법에 대해 다뤄보고자 한다.



분산 처리

지난 포스팅에서 허용 지연시간 달성을 위한 알고리즘에 대해 알아보았다.

이번에는 
	0.	시스템 디자인 측면에서 성능 개선에 어떤 방법이 있는지(스케일업 vs 스케일 아웃)
	0.	가용성을 확보하기 위해서 어떤 방법들이 있는지
	0.	어떤 저장소를 선택할 것인지(SQL, NoSQL 비교)

이번엔 SNS의 가장 중요한 요구사항 중 하나인 ‘가용성’을 보장하는 방법을 알아보려 한다.

가용성은 availability라고도 하고 결함 내성fault-tolerance이라고도 할 수도 있다.

availability는 기본적으로 분단 내성partition-tolerance을 전제로 한다.

보통 고가용성에 대해 논할 때 흔히 한 대 이상의 리더(마스터) 노드와 다수 대의 팔로워(또는 레플리카) 노드를 두고, 리더 노드나 네트워크에 문제가 생겼을 시 팔로워 노드를 리더 노드로 승격시켜 쓰기 작업을 할 수 있도록 한다.

읽기 요청에 대한 처리는 보다 간단하다. 한 노드에 문제가 생긴다면 다른 노드에서 읽기를 처리하면 된다.

다만 여기에서 한 가지 트레이드 오프가 있다. 바로 선형성이다.

선형성을 보장하는 애플리케이션에서는 쓰기 작업이 모든 리더와 팔로워 노드에 동기화 됨을 보장한다. 선형성linearization을 보장하는 애플리케이션은 모든 요청에 대한 일관성consistency 있는 응답을 보장하거나, 불가시 아예 반환하지 않는데(장애가 복구될 때 까지 기다리거나 오류 반환), 이 때 가용성availability을 포기하게 된다.

가용성availability은 모든 요청에 대한 응답을 반드시 보장한다. 단, 여기에서 트레이드 오프가 생기는데, 데이터가 최신이 아닐 수도 있다는 것이다. 즉, 선형성과 데이터의 일관성consistency를 포기한다.

다만 시간이 흐르면서 장애가 복구되거나 하여 분산 노드간 데이터는 최종적으로 일관성을 갖게 되는데 이를 최종적 일관성eventual consistency라고 한다.

네트워크가 올바르게 동작할 때는 시스템이 일관성(선형성)과 완전한 가용성 모두를 제공할 수 있다. 하지만 네트워크 장애는 일종의 결함이고 상시적이며 선택할 수 있는 것이 아니므로, 네트워크 분단이 생겼을 때 일관성consistency과 가용성availability 중 하나를 선택하라는 것이 (보다 현실적 의미의)CAP 정리이다. 참고로 현실에서 실제로 선형적인 시스템은 굉장히 드물다.

정리하자면
Consistency: 모든 시스템은 특정 순간 항상 같은 데이터를 갖는다.
Availability: 시스템에 대한 모든 요청에 항상 응답을 반환할 수 있다.
Partition Tolerance: 네트워크 분단(network partition) 등 어떤 상황에서도 시스템은 동작할 수 있다.
이다

eventual consistency는 분산 환경에서 가용성을 위한 주요 성질(?) 중 하나로, 분산 환경의 BASE 원칙의 일부이기도 하다.

Basically Available(‘기본적으로’ 가용하다는 뜻으로, 데이터는 항상 가용하되 일관성이 보장되지 않음을 뜻한다)
Soft state: 일관성이 보장되지 않기에 상태(state)에 대해 명확히(solid) 정의할 수 없다
Eventual Consistency: 충분한 시간이 흐를시 시스템의 모든 데이터는 최신 상태가 보장된다


분단 내성
가용성을 위해 전제되는 조건이 있다. 바로 분단 내성partition-tolerance이다. 분단 내성은 기본적으로 다수 개의 노드가 서로 네트워크로 연결되어 있고, 그 중 일부의 네트워크에 장애가 생기는 경우에도 시스템이 정상동작하는 능력을 뜻한다.





요구사항

확장의 방법
먼저 확장에는 스케일업(수직확장)과 스케일아웃(수평확장)이 있다.


스케일업

스케일 업은 단일 서버(하드웨어)의 성능을 증가시켜서 더 많은 요청을 처리하는 방법이다. 단일 하드웨어의 성능을 높이기 위해 CPU, 메모리, 하드디스크를 업그레이드 하거나 추가하는 것이다. 

스케일업

	0.	단순성: 확장이 기술적으로는 복잡하지 않다. 단순히 CPU나 RAM, 저장소를 추가하기만 하면 된다.
	0.	호환성: 애플리케이션이 분산 환경을 감안하지 않아도 된다.
	0.	성능: 집중 연산 능력을 요구하는 일부 작업에 효과적이며, 모든 자원들이 한 하드웨어 내에서 모두 연결돼있으므로 지연이 보다 낮을 수 있다.

수직확장에는 다음과 같은 명확한 한계가 존재한다.

0. 비용: 성능이 높이질 수록 개선 성능 대비 비용 효과가 줄어들어 비싸다.
1.아무리 좋은 하드웨어와 고사양 부품이 있다고 하더라도 단일 장비에 설치할 수 있는 슬롯에 한계가 있을 것이다.
2. SPOF: 장애에 취약하다. 만약 고사양의 서버에 장애가 생기면 그만큼 타격이 클 수 밖에 없다.
3. 중간에 부하가 늘어나 추가로 확장하기 위해선 스케일업 과정중 백업할 비슷한 사양의 1회성 서버가 한 대 더 필요하고 불필요한 비용이 발생하게 된다. 또한 늘어나는 속도를 예측하지 못할시 중간에 서버를 중단시켜야 할 수 있고, 기존 서버 데이터를 옮기고 데이터를 정리하려면 그 작업 시간만큼 서비스가 중단될 것이다. 이 작업은 적게는 수 시간에서 많게는 하루 이상이 걸릴 수 있는데, 사용자가 늘어날 때마다 이런 작업을 반복할 수는 없다.

확장성이 없다.

스케일아웃

스케일아웃은 동일 사양의 새로운 서버(하드웨어)를 추가하는 것이다.

장점

	0.	유연성: 필요에 따라 장비를 추가하거나 줄일 수 있어 비용효과적이다.
	0.	내결함성: 고가용성을 제공할 수 있고 데이터 분산을 통해 특정 장비의 결함에 보다 단단하다.
	0.	확장성: 기본적으로 얼마나 확장할지에 대한 상한이 없으며 계속 노드를 추가할 수 있다.
	0.	로드밸런싱: 로드밸런싱을 통해 부하를 고르게 분산시킬 수 있다.

단점

	0.	복잡성: 분산을 위해 더 복잡한 시스템 아키텍처가 필요하며, 소프트웨어가 분산 환경에서 동작할 수 있어야 한다.
	0.	관리: 노드가 늘어날 수록 노드를 관리할 수 있는 시스템이 더 많이 필요하게 되며, 운영에 필요한 부하와 복잡성이 증가한다.
	0.	네트워크 의존성: 노드간 네트워크 장애나 지연에 취약하다
	0.	비일관성inconsistency: 노드간 데이터 일관성과 동기화 이슈가 있을 수 있다.




트위터 요구사항

가용성: 무슨 일이 있어도 데이터는 항상 가용해야 한다. ‘모든 클라이언트의 읽기와 쓰기 요청에 대하여 항상 응답이 가능해야 함을 보증하는 것.’ 전편에서 언급됐듯이, SNS에서 가용성은 가장 민감한 이슈이다. 장애에 빠르게 복구가 불가하다면 이는 곧 사용자 이탈로 이어질 수 있다. 데이터를 분산하여 SPOF를 줄이는 것이 중요하다.

일관성, 정합성: 데이터에 대한 일관성 요구는 비교적 덜할 수 있다. 예를 들어 계좌 이체 서비스에서 아주 잠깐이라도 계좌의 잔고가 다르게 조회된다면 치명적인 문제를 야기할 수 있다. 하지만 트위터의 경우 일시적으로 사용자간 데이터가 다르게 표시된다고 한들 큰 문제가 발생하지는 않고 사용자들이 그렇게 요구하지도 않는다.

유연성 필요: 유저 베이스가 큰 만큼 트래픽도 편차가 심할 수 있고 유연성이 필요할 수 있다. 어떨 땐 사용자 수가 폭발적으로 늘어나거나 심하게 쏠림현상이 생길 수도 있다. 예를 들어 주말 오후나 저녁 시간대에는 트래픽이 많이 쏠리고, 평일 오전 오후에는 트래픽이 훨씬 적을 수 있다.

데이터 특성: 개별 요청의 빈도는 크지만, 각각의 요청에 요구되는 연산은 비교적 매우 단순하다.

글로벌: 트위터는 글로벌 서비스이고, 더 낮은 지연시간을 위해 세계 각 지역에 각각의 데이터 센터를 구축해 관리할 필요가 있다. 따라서 분산 환경이 더 적합하고 효율적일 수있다.

	•	이를 보아 스케일업보다 스케일아웃을 선택함이 매우 타당하다고 볼 수 있다.


어떤 저장소를 선택해야 할까? 

데이터 측면에서의 트위터 요구사항


트위터의 데이터 규모 -> 확장성

MySQL에서의 설계를 기준으로 트윗 한개의 용량은 1,156 bytes이다.
(id(UUID) 16 bytes + text (280 characters) 1120 bytes + user_id(UUID) 16 bytes + timestamp 4 bytes)

그렇다면 하루에 쌓이는 트윗의 용량(초당 6,000개 쓰기)은 558 GB/일이다.
(1,156 bytes * 6,000/초 = 6,936,000 bytes/초 = 599,270,400,000 bytes/일)

RDB로 감당이 가능할까? RDB는 확장성을 제공하나? 분산을 제공 하나?

—
4,500,000 개 트윗 읽기/초
6,000 개 트윗 쓰기/초

트윗 1개 1,156 byte

유통
1,156 byte * 4,506,000 / s
= 5,208,936,000 byte / s
= 4.85 GB / s

5,208,936,000 byte * 60 s * 60 m * 24 h
= 450,052,070,400,000 bytes / 일
= 419,144 TB / 일

생성
1,156 byte * 6,000 / s
= 6,936,000 byte / s 생성
= 599,270,400,000 / 일 생성
= 558.11 GB / 일 생성


비정형성 -> 데이터 모델

트위터의 핵심은 타임라인(모아보기)이다.

두 번째는 비정형성이 있다. 지난 포스팅의 2번째 방법인 fan-out 방법의 경우, 각 유저마다 타임라인을 구성해야 한다. 즉, 유저별로 타임라인이라는 데이터를 저장하게 될 것이고, 모든 유저의 타임라인은 다르게 생겼을 것이다. 즉, 데이터가 비정형이다.

그렇다면 이런 상황에서 어떤 선택지가 있을까?





RDB의 특성이 확장성을 제공할 수 없는 이유, CAP

ACID 강한 일관성











역사적으로 데이터를 하나의 큰 트리(계층 모델)로 표현하려고 노력했지만 다대다 관계를 표현하기에는 트리 구조가 적절하지 않았다.

이 문제를 해결하기 위해 관계형 모델이 고안됐다.

최근 개발자들은 관계형 모델에도 적합하지 않은 애플리케이션이 있다는 사실을 발견했다.

새롭게 등장한 비관계형 데이터저장소인 NoSQL은 다음과 같은 두 가지 주요 갈래가 있다.

문서 데이터베이스: 데이터가 문서 자체에 포함돼 있으면서 하나의 문서와 다른 문서 간 관계가 거의 없는 사용 사례를 대상으로 한다.

그래프 데이터베이스: 문서 데이터베이스와는 정반대로 모든 것이 잠재적으로 관련 있다는 사용 사례를 대상으로 한다.

문서 및 그래프 데이터베이스가 가진 공통점 중 하나는 일반적으로 저장할 데이터를 위한 스키마를 강제하지 않는다는 점 -> 변화하는 요구사항에 맞춰 애플리케이션 쉽게 변경 가능





확장성과 NoSQL

데이터를 분할해 저장하는 방식을 파티셔닝이라고 하는데, 상상조차 불가능한 양의 데이터, 그리고 비정형 데이터가 포함된 데이터를 분산해 저장하고 사용하는 방법을 연구하며 발전한 NoSQL이란 기술이 있다.

NoSQL이 등장하게 된 이유에는 기본적으로 RDBMS의 확장성에 기인한다. RDB도 파티셔닝을 지원하긴 하지만, 태생적으로 확장 가능한 분산 환경을 사용함에는 한계가 있다.

데이터가 적거나 요청량이 적을 때, 증가량을 사전에 예측할 수 있을 때는 일반 RDBMS를 사용해도 문제가 없겠지만,

데이터 증가량을 측정하기 어렵거나, 서비스 요청량 증가를 예측하기 어려운 상황에서는 NoSQL 저장소로 옮기는 것이 현명한 선택이 될 것이다.

이에 NoSQL을 사용해야한다?



선택지 - NoSQL

NoSQL이란 빅데이터를 처리하기 위한 분산 데이터 저장소의 통칭

NoSQL의 정의에 대해 명확히 합의된 바는 없지만, 대표적으로:

마틴파울러의 NoSQL의 정의를 보자면
	⁃	대용량 웹 서비스를 위해 만들어진 데이터 저장소
	⁃	관계형 데이터 모델을 지양하며 대량의 데이터를 저장하고 조회하는 데 특화된 저장소
	⁃	스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소


관계와 확장성

관계를 지양함으로써 얻는 이점은 데이터를 분산 저장할 때.

트윗 모아보기의 예를 들어보자. 내가 팔로잉하는 유저1의 트윗이 노드1에 있다고 가정해보자. 팔로잉 유저2의 트윗이 노드3에 있다면? 먼저 모든 팔로잉을 찾아야 하고, 그 이후 각각의 팔로잉 유저가 작성한 모든 트윗을 탐색해야 한다. 내가 누구를 팔로잉하는지 찾기 위해선 n개의 노드를 순회하며 모두 찾아야만 할 것이고, 또 팔로잉이 작성한 트윗이 무엇인지 찾기 위해서 다시 n개의 노드를 순회해야 한다.

어디어디에 따르면 파티셔닝시 10배가 느려진다는 말이 있다.

설령 트윗의 작성자를 consistent hashing의 identifier로 하여 작성자별로 파티셔닝을 했다고 하자. 만약 다른 API에서 트윗 작성자가 아닌 트윗의 고유 id로 특정 트윗의 정보를 찾아야 한다면? n번의 순회가 필요할 것이다. 관계가 복잡해질 수록 애플리케이션 구현의 복잡도가 기하급수적으로 늘어날 것이고, 유지보수도 어려워질 것이다.

이렇게 관계로 얽히고 섥힌 구조에서는 탐색이 어려울 수 밖에 없다.

반면 NoSQL은 관계 자체를 지양한다. 각각의 개별 로우로만 데이터를 구분하니 O(1)로 데이터를 곧바로 얻을 수 있고, 중첩 구조를 지원해 복잡한 구조도 저장할 수 있도록 한다. 따라서 파티셔닝(샤딩)이 용이하고 자동 샤딩또한 지원한다.

고유 특징: 쓰기/읽기 성능 특화, 2차 인덱스 지원, 자동 샤딩 지원
일반적으로 NoSQL은 관계형 데이터베이스에 비해 쓰기와 읽기 성능이 월등히 빠르다.

NoSQL은 태생적으로 관계를 지양하고 스키마가 없기 때문에 분산처리에 자유롭고 분산 환경에서 잘 동작하도록 설계되어 있다. 즉, 동일한 성격의 데이터가 물리적으로 다른 하드웨어에 저장되고 조회된다.







그렇다면 NoSQL에서 고려해야할 사항에는 어떤 것들이 있을까?

일관성 모델

선형성

제공하는 서비스에서 어느 정도의 일관성이 필요한지. 일관성 레벨. 
동기식 vs 비동기식
일관성 vs. 최종일관성. cost는 응답시간. 

tweet은 강한 일관성이 별로 필요 없다
수정이 없기 때문이다

그보단 빠른 데이터 전달이 우선.

	⁃	mongodb, redis, cassandra, graph

cost: 응답시간latency

동기식-선형성 vs. 비동기식
일관성 vs 최종 일관성

Redis
AOF(append only file, RDB)

결국 분산에서 성능은 락과 관련이 있다. 모든 노드에 락을 걸어야하면 성능이 떨어지는 대신 일관성이 올라가고, 안걸수록 성능이 올라가고 일관성이 떨어진다. RDB가 성능이 떨어지는 이유. NoSQL이 성능이 빠른 이유.




데이터 모델

키-값과 같이 간단한 데이터 모델로 처리 가능? 

문서 모델과 같이 중첩 구조 지원하는지






읽기, 쓰기 성능: 

성능-읽기 성능, 쓰기 성능

	•	읽기 비율: 인덱싱 b-tree
	•	쓰기 비율: lsm tree
	•	읽기 쓰기 비율: in-memory(disk-based vs. in-memory-based)

NoSQL이 필요한 경우:

	•	대량의 단순 정보를 빠르게 쓰고 읽을 때
	•	관계형 데이터베이스가 처리하지 못하는 대량의 데이터를 입력할 때(보통 수십 기가바이트의 데이터)
	•	스키마가 고정되지 않은 데이터를 저장하고 조회할 때 등

관계형 데이터베이스 특성상 제공 가능한 성능에 한계가 있다







단일 고장점: 

단일 고장점이란 시스템을 구성하는 개별 요소 중 하나의 요소가 망가졌을 때 시스템 전체를 멈추게 만드는 요소이다. 단일 고장점을 가진 NoSQL은 자체적으로 가용성을 지원하지 못한다. 별도 솔루션 함께 사용하기도.

—
단일 고장점 여부

해당해도 쉬운 복구가 가능한지

eg. HBase 단일 고장점 있지만 장애 상황에서 하드웨어적인 방법으로 빠른 복구 가능

무정지 서비스 중요 목표라면 단일 고장점 NoSQL 피해야






무중단 시스템

시스템 확장시 중단이 필요한지 여부와 같은 시스템의 특성 확인해야
eg. MongoDB 자동 샤딩 -> 운영중 시스템 추가 가능
자동 샤딩 중 서비스 응답시간 느려지기도






저장 방식에 따른 분류

데이터 접근을 위해 키 사용
키에 저장된 값의 ‘데이터 모델’에 따라 분류

크게 키-값 모델, 문서 모델, 컬럼 모델, 그래프 모델로 분류할 수 있다.




원자성 지원

트랜잭션 지원 여부,
단일 연산에 대한 원자성 지원 여부
등

원자성 지원이 어느 쪽(서버, 클라이언트)에서 지원되는지 확인
클라이언트에서 지원하는 단일 연산 원자성은 코드 복잡성 증가시킬 수 있다


memcached? -> 캐싱 솔루션으론 부적합. string만 지원.






샤딩 필요성?p77
해시 테이블은 메모리에 저장해야 하므로 키가 너무 많으면 문제가 된다. 디스크상의 해시 맵에 좋은 성능 기대 어렵다. -> redis 샤딩 필요성? 무작위 접근 i/o가 많이 필요하고 디스크가 가득 찼을 때 확장하는 비용 비싸며 해시 충돌 해소 위해 성가신 로직 필요
해시 테이블은 범위 질의에 효율적이지 않다. 해시 맵에서 모든 개별 키 조회 필요. -> redis 써야 하는 이유. sorted set.








희미해지는 SQL과 NoSQL의 경계











—
인메모리 데이터베이스

지속성

변경 사항 로그 기록
주기적인 스냅숏
복제


—
Redis AOF

키 설계
skip-list

레디스 클라이언트 설정
샤딩
일관성 해싱





가용성+쓰기 성능 개선을 위한 클러스터 구성

	⁃	Redis Sentinel

	⁃	Redis Cluster
















요구사항 분석
해결 방안

선택

구현

reference



