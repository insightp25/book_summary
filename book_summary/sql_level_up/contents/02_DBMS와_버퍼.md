## 2강 DBMS와 버퍼

### 접근 속도 VS 기억 비용
- 데이터 정합성(영속성)과 성능(속도)의 트레이드오프
- 일반적인 SQL 구문은 실행 시간 대부분 저장소 I/O(입출력)에 사용
- 디스크 접근을 줄일 수 있다면 큰 폭의 성능 향상 가능

#
### 성능 향상을 목적으로 데이터를 저장하는 메모리
- 데이터 캐시cache: 조회 처리(SELECT 구문)와 관련
  - 문제: 저장소에 매번 접근->성능 저하
  - 솔루션: 디스크에 있는 데이터의 일부를 메모리에 유지
- 로그 버퍼buffer: 갱신 처리(INSERT, DELETE, UPDATE, MERGE 구문)와 관련
  - 문제: 메모리에 있는 데이터의 휘발성
  - 솔루션: 비동기 처리-커밋과 데이터 영속화 분리
    1. 커밋commit 시점에 갱신 정보 '로그 파일'로 영속화
    2. 이후 커밋 데이터 영속화
  - 그럼에도 커밋 시 디스크에 동기 접근(로그 파일), 지연 가능성 증가, 또 다시 트레이드오프

#
### 데이터 캐시와 로그 버퍼의 크기
- 데이터 캐시(검색) VS 로그 버퍼(갱신)
- 데이터베이스는 기본적으로 검색을 메인으로 처리한다고 가정, 대부분의 RDBMS에서 월등히 큰 데이터 캐시 할당
- 필요에 따라 로그 버퍼의 크기를 늘리는 등 튜닝(최적화) 가능
- 모든 것을 자동 설정에 의지하는 일은 굉장히 위험하며, 데이터베이스가 어떤 생각에 기반을 두고 리소스를 배분하고 있는지를 이해하는 것이 중요

#
### 워킹 메모리 영역
- 정렬, 해시 관련 처리에 사용되는 작업용 영역
- 이 영역이 부족해지면 대부분의 DBMS가 저장소 사용->성능 저하
- 여러 개의 SQL 구문을 동시에 실행하면 메모리가 넘치는 경우가 있고, 미리 판별이 어려우므로 그러한 상황을 재현하는 부하 검사 필요
