# 07장. 트랜잭션

## 애매모호한 트랜잭션의 개념
### 원자성*Atomicity(more like 'Abortability')*
<br></br>
---
### 일관성*Consistency*

> 원자성, 격리성, 지속성은 데이터베이스의 속성인 반면 (ACID에서의)일관성은 애플리케이션의 속성이다. 애플리케이션에서 일관성 달성을 위해 데이터베이스의 원자성과 격리성 속성에 기댈 수 있지만 데이터베이스만으로 되는 것은 아니다. 따라서 C는 실제로는 ACID에 속하지 않는다 ~~(마케팅 구호이다.)~~.

회계 시스템에서 모든 계좌에 걸친 대변과 차변은 항상 맞아떨어져야 한다는 선언(불변식*invariant*)과 같이, 트랜잭션이 어떤 불변식이 유효한 데이터베이스에서 시작하고 트랜잭션에서 실행된 모든 쓰기가 유효성을 보존한다면 불변식이 항상 만족된다고 확신할 수 있다.

하지만 일관성의 아이디어는 애플리케이션의 불변식 개념에 의존하고, 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 **애플리케이션의 책임**이며, 이는 데이터베이스가 보장할 수 있는 게 아니다. 데이터베이스는 불변식을 위반하는 잘못된 데이터를 쓰지 못하도록 막을 수 없다.
<br></br>
---

### 격리성*Isolation*
<br></br>
---

### 지속성*Durability*
<br></br>

---
### 단일 객체 연산과 다중 객체 연산

ACID 원자성, 격리성은 클라이언트가 한 객체 내에서 여러 번의 쓰기를 하면 데이터베이스가 어떻게 해야 하는지를 서술한다.

- 원자성: 전부 반영되거나, 아무것도 반영되지 않는 것을 보장함으로써 부분 실패를 걱정할 필요가 없어진다.
- 격리성: 동시 트랜잭션들은 서로를 방해해선 안된다. eg. 한 트랜잭션이 여러번 쓴다면 다른 트랜잭션은 

ACID의 정의상으로, 한 번에 여러 객체(로우, 문서, 레코드)를 변경할 수 있다고 가정한다. **다중 객체 트랜잭션**은 흔히 데이터의 여러 조각이 동기화된 상태로 유지돼야 할 때 필요하다.

다중 객체 트랜잭션은 어떤 읽기 연산과 쓰기 연산이 동일한 트랜잭션에 속하는지 알아낼 수단이 있어야 하고, RDB에서 이것은 전형적으로 <u>클라이언트와 데이터베이스 서버 사이의 TCP 연결을 기반으로 한다</u>(TCP 연결이 끊기는 경우가 있으므로 이상적인 방법은 아니고, 고유 트랜잭션 식별자를 사용해 연산을 묶는 대체방법이 있다).

반면 non-RDB는 이런 식으로 연산을 묶는 방법이 없는 경우가 많으며, 다중 객체 API(eg. 키-값 저장소의 multi-put)가 있더라도 반드시 트랜잭션 시맨틱을 의미하진 않는다. 즉, 어떤 키에 대한 연산은 성공, 일부는 실패해 DB가 부분적으로 갱신된 상태가 될 수 있다.
<br></br>
#### 단일 객체 쓰기

> 20KB의 JSON 문서를 데이터베이스에 쓰는 도중 네트워크 연결이 끊기고 10KB만 전송되었다면 파싱 불가능한 10KB의 JSON 조각을 저장할 것인가?

저장소 엔진들은 거의 보편적으로 <u>**한 노드에 존재하는 단일 객체 수준(키-값 쌍 같은)에서 원자성과 격리성 제공**</u>을 목표로 한다. 원자성은 장애 복구(crash recovery)용 로그를 써서, 격리성은 각 객체에 잠금을 사용해(동시에 한 스레드만 객체에 접근하도록) 구현할 수 있다.

어떤 DB는 compare-and-set과 같은 연산을 제공하기도 한다.

이러한 단일 객체 연산은 여러 클라이언트에서 동시에 같은 객체에 쓰려고 할 때 <u>갱신 손실(lost update)을 방지</u>하므로 유용하다. 단, 일반적으로 쓰이는 의미의 트랜잭션이 아니며, 트랜잭션은 보통 <u>다중 객체에 대한 다중 연산을 하나의 실행 단위로 묶는 메커니즘</u>으로 이해된다.
<br></br>
#### 다중 객체 트랜잭션의 필요성

- 다중 객체 트랜잭션은 여러 파티션에 걸쳐서 구현하기 어렵고,
- 매우 높은 가용성과 성능이 필요한 곳에서는 방해가 되는 시나리오도 있기 때문에

많은 분산 데이터 스토어는 다중 객체 트랜잭션 지원을 포기했다(하지만 막는 것도 없다).

단일 객체 연산만 사용해도 충분한 사례도 있지만, 많은 경우 다중 객체에 실행되는 쓰기 작업은 코디네이션이 필요하다.

- 관계형 데이터 모델에서는 다른 테이블의 로우를 참조하는 외래 키를 종종 가지며, 다중 객체 트랜잭션은 <u>참조가 유효한 상태로 유지되도록 보장해준다</u>.
- (문서 데이터 모델의 경우)
- (보조 색인 관련 경우)

트랜잭션이 없더라도 애플리케이션들을 구현할 수 있으나,
- 원자성이 없으면 오류처리가 훨씬 더 복잡해지고
- 격리성이 없으면 동시성 문제가 생길 수 있다.
<br></br>
#### 오류와 어보트 처리
<br></br>
---

## 완화된 격리 수준

_동시성 문제(경쟁 조건).

동시성 버그는 타이밍에 운이 없을 때만 촉발되기 때문에 테스트로 발견이 어렵고 일반적으로 재현하기도 어렵다. 동시성은 추론하기도 매우 어렵다. 특히 어떤 코드 조각에서 데이터베이스에 접근하는지 확실히 알지 못할 수도 있는 커다란 애플리케이션에서 그렇다.

데이터베이스는 오랫동안 트랜잭션 격리를 제공함으로써 애플리케이션 개발자들에게 동시성 문제를 감추려고 했다.

_직렬성 격리, 성능 비용. 완화된 격리 수준은 '**어떤**' 동시성 이슈로부터는 보호해주지만 모든 이슈로부터 보호해주지는 않음.

_동시성 문제의 종류와 방지하는 방법, 신뢰성 있는 애플리케이션.

_실무 사용 완화된(비직렬성) 격리 수준, 발생할 수 있는 경쟁 조건, 발생할 수 없는 경쟁 조건, 직렬성 설명.
<br></br>

---
### 커밋 후 읽기*read committed*

가장 기본적 수준의 트랜잭션 격리. 두 가지 보장.

1. DB에서 읽을 때 커밋된 데이터만 보게 된다(더티 읽기 없음).
2. DB에 쓸 때 커밋된 데이터만 덮어쓰게 된다(더티 쓰기 없음).
<br></br>
#### 더티 읽기 방지

더티 읽기*dirty read*: 트랜잭션이 DB에 데이터를 썼지만 아직 커밋/어보트 되지 않았을 때 다른 트랜잭션에서 해당 커밋되지 않은 데이터를 읽는 것.

커밋 후 읽기 격리 수준에서는 더티 읽기를 막아야 한다.

부분적으로 갱신된 상태에 있는 데이터베이스를 보는 것은 사용자에게 혼란을 유발하고 다른 트랜잭션들이 잘못된 결정을 하는 원인이 될 수도 있다.

트랜잭션이 어보트 되면 그때까지 쓴 내용은 모두 롤백되어야 한다. 하지만 더티 읽기 허용시 다른 트랜잭션이 데이터베이스에 커밋되지 않을 데이터(롤백 될 데이터)를 보게 되고 결과 판독에 복잡성을 더하게 된다.
<br></br>
#### 더티 쓰기 방지

더티 쓰기*dirty write*: 먼저 쓴 내용이 아직 커밋되지 않았고 나중에 실행된 쓰기 작업이 커밋되지 않은 값을 써버리는 것.

커밋 후 읽기 격리 수준에서는 더티 쓰기를 막아야 한다.
<br></br>
#### 커밋 후 읽기 구현

- <u>**더티 쓰기 방지 구현**</u>: 가장 흔한 방법으로 <u>로우 수준 잠금*lock*을 사용</u>한다.

- <u>**더티 읽기 방지 구현**</u>:
  - 옵션1: 특정 객체에 잠금을 갖고 쓰기 중인 트랜잭션이 완료될 때까지 기다렸다가(잠금 대기), 잠시 잠금을 획득한 후 읽기가 끝난 후 바로 해제하게 할 수 있다.
    - 하지만 읽기 잠금을 요구하는 방법은 오랫동안 실행되는 쓰기 트랜잭션 하나가 완료될 때까지 기다려야 하므로 실무에서는 잘 동작하지 않는다. 
      - 읽기만 실행하는 트랜잭션들의 응답 시간에 해를 끼치고
      - 운용성이 나쁘며,
      - 잠금 대기 때문에 애플리케이션 일부 발생 지연이 애플리케이션의 완전히 다른 부분에 연쇄 효과를 미칠 수 있기 때문이다.
  - 옵션2: (<u>**잠금을 걸지 않고 과거 커밋된 값을 읽는다**</u>)데이터베이스는 쓰여진 모든 객체에 대해
    - 과거에 커밋된 값과
    - 현재 쓰기 잠금을 갖고 있는 트랜잭션에서 쓴 새로운 값

    을 모두 기억하고, 해당 트랜잭션이 실행 중인 동안 그 객체를 읽는 다른 트랜잭션들은 과거의 값을 읽게 된다. 새 값이 커밋돼야만 다른 트랜잭션들이 새 값을 읽을 수 있게 된다.
<br></br>
---

### 스냅숏 격리와 반복 읽기
읽기 트랜잭션 도중에 다른 쓰기 트랜잭션이 들어와 커밋 하고, 아직 종료되지 않은 읽기 트랜잭션 내에서 쓰기로 변경된 커밋된 필드 읽기시 변한 값을 읽게 된다. 이런 현상을 **비반복 읽기*nonrepeatable read*** 또는 **읽기 스큐*read skew*** 라고 한다.

보통의 경우 이런 문제는 일시적이지만, 어떤 상황에서는 이런 일시적인 비일관성을 감내할 수 없는 경우도 있다.

- eg. _백업, 분석 질의, 무결성 확인 등의 상황(주로 DB 전체나 큰 부분을 스캔하는, 오래 걸리고 읽기만 실행하는 경우)

**스냅숏 격리**는 이런 문제의 가장 흔한 해결책이다. 트랜잭션은 시작할 때 DB에 키밋 상태였던 모든 데이터를 보며, 데이터가 나중에 바뀌어도 각 트랜잭션은 <u>**특정한 시점의 과거 데이터를 보게 된다**</u>.

트랜잭션이 특정 시점에 고정된 DB의 일관된 스냅숏만 볼 수 있다면 이해하기가 훨씬 쉬워진다.
<br></br>



#### 스냅숏 격리 구현

커밋 후 읽기 격리처럼 더티 쓰기를 방지하기 위해 쓰기 잠금을 사용한다. 그러나 읽을 때는 아무 잠금도 필요 없다. 스냅숏 격리의 핵심 원리는
- 읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고
- 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다

는 것이다.

스냅숏 격리 구현을 위해 DB는 더티 읽기를 막는 데 쓰는 메커니즘을 일반화한 방법을 사용한다. DB는 진행 중인 여러 트랜잭션에서 서로 다른 시점의 DB 상태를 봐야할 수도 있기 때문에, 객체마다 커밋된 버전 여러 개를 유지할 수 있어야 한다. DB가 객체의 여러 버전을 함께 유지하므로 이 기법은 <u>**다중 버전 동시성 제어*multi-version concurrency controll, MVCC***</u>라고 한다. 

커밋후 읽기 격리만 필요하다면 커밋된 버전, 커밋되지 않은 버전 두 개씩만 유지하면 충분하나, 스냅숏 격리 지원 저장소 엔진은 보통 커밋 후 읽기 격리를 위해서도 MVCC를 사용한다. 전형적인 방법은
- 커밋 후 읽기: 질의마다 독립된 스냅숏 사용
- 스냅숏 격리: 전체 트랜잭션에 대해 동일한 스냅숏 사용

eg. PostgreSQL
트랜잭션이 시작하면 계속 증가하는 고유한 트랜잭션 ID를 할당받고, 트랜잭션이 데이터베이스에 데이터를 쓸 때마다 쓰기를 실행한 트랜잭션의 ID가 함께 붙는다.

테이블 각 로우에는 그 로우를 테이블에 삽입한 트랜잭션 ID를 갖는 `created_by` 필드와, 처음에는 비어있는 `deleted_by` 필드가 있다. 트랜잭션이 로우 삭제시 실제 DB에서 지우지 않고, <u>**`deleted_by` 필드를 삭제 요청 트랜잭션의 ID로 설정함으로써 지워졌다고 표기**</u>한 후, <u>**나중에 아무 트랜잭션도 해당 데이터에 접근하지 않는 게 확실해지면**</u> DB 가비지 컬렉션 프로세스가 <u>**지워졌다고 표시된 로우들을 삭제**</u>하고 사용량을 줄인다. <u>**갱신은 내부에서 삭제와 생성으로 변환**</u>된다.
<br></br>
#### 일관된 스냅숏을 보는 가시성 규칙

<br></br>
#### 색인과 스냅숏 격리

<br></br>
#### 반복 읽기와 혼란스러운 이름


<!--

<u>****</u>
<u>****</u>
<u>****</u>
<u>****</u>
<u>****</u>
<u>****</u>
<u>****</u>
<u>****</u>
<u>****</u> 

-->