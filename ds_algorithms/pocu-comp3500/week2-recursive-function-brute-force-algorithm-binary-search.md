# WEEK2: 재귀함수, 주먹구구식 알고리듬, 이진 탐색

# 재귀 함수의 장단점

|장점|단점|
|---|---|
|가독성이 좋음|재귀적 문제 분석/설계가 안 직관적|
|코드가 짧음|맹목적인 믿음이 필요 - 수학적 귀납법을 이해하면 믿음이 생김|
|각 단계의 변수 상태 자동 저장 - 함수의 스택프레임 덕분|스택 오버플로 발생 가능 - 재귀함수 호출이 너무 깊은 경우|
|코드 검증도 쉬움|함수 호출에 따른 과부하|




<br>

# 꼬리 재귀

## 읽기 좋은 코드 작성이 기본!

- 기본적으로 재귀 함수를 사용하는 게 나은 방법
  - 가독성이 좋고 유지보수가 쉬운 코드가 더 중요
- 다음과 같을 경우 반복문으로 변환
  - 스택 오버플로가 날 가능성이 있는 경우
  - 성능 문제가 일어날 가능성이 큰 경우
  - 성능 문제가 확인된 경우
- 모든 재귀 함수는 반복문으로 작성 가능
  - 복잡한 경우 스택 등의 데이터 구조를 사용해야 함

그런데, 단점이 없는 재귀도 있다!


## 꼬리 호출(tail call)

- 함수 코드 제일 마지막에서 다른 함수 호출하는 경우
- 그 후에 실행하는 명령어가 없음


## 꼬리 호출과 스택 프레임

- 스택 프레임이 존재하는 이유
  - 함수에서 사용중인 변수 값을 유지하기 위해
  - 타 함수 호출후 반환되면 스택에 저장했던 값을 되돌려 사용
- 꼬리 호출의 경우는 타 함수로부터 반환후 더 이상 연산이 없음
  - 곧바로 호출자로 반환
- 따라서 스택 프레임에 저장해 놓은 변수 값을 재사용하지 않음 -> 사실상 스택 프레임 사용할 이유가 없는 것.
- 이런 경우 컴파일러가 스택 프레임을 따로 안 만드는 최적화를 하기도 함
  - 꼬리 호출 제거(tail call elimination, TCE)
  - 꼬리 호출 최적화(tail call optimization, TCO)
  - 프로그래밍 언어/컴파일러에 따라 지원하는 경우도, 안하는 경우도 있다.

## 꼬리 재귀(tail recursion)

- 꼬리 호출의 특수한 경우
- 마지막에 호출하는 함수(꼬리 호출)가 자기 자신(재귀)
- 꼬리 호출과 똑같은 최적화가 적용됨

## 팩토리얼 재귀 함수

```java
int factorialRecursive(int n) {
    if (n <= 1) {
        return 1;
    }

    return n * factorialRecursive(n - 1);
}
```

이 함수는 꼬리 재귀일까?? -> ***NOPE***

함수 호출이 마지막 줄에 있긴 하지만 마지막 명령어가 있다(재귀함수 값에 n을 곱하는 추가 연산이 있다).






<br>

# 꼬리 재귀 함수 작성하기

## 팩토리얼 꼬리 재귀 함수

```java
int factorial(int n) {
    return factorialRecursive(n, 1);
}

int factorialRecursive(int n, int fac) {
    if (n <= 1) {
        return fac;
    }

    return factorialRecursive(n - 1, n * fac); // <- 이 함수 호출이 마지막 명령어! 함수에서 돌아오면 따로 할 일/연산이 없다.
}

```

예시:

f0 == factorial(int n)

f == factorialRecursive(int n, int fac)

f0(5) -> f(5, 1) -> f(4, 5 * 1) -> f(3, 4 * 5) -> f(2, 3 * 20) -> f(1, 2 * 60) -> 120


## 꼬리 재귀 함수 작성하기

- 보통 꼬리 재귀 함수가 덜 직관적
- 그러나 이런 식으로 작성된 코드가 종종 보임
- 가장 큰 이유는 앞에서 말했던 최적화

하지만 꼬리 호출 최적화를 지원 안 하는 언어라면 어떻게 할까요? -> 가독성을 위해 일반 재귀 함수로 작성하지 않을까요? -> 맞다. 하지만 이건 알아두자!

- 하지만 꼬리 호출 최적화를 지원 안 하는 언어라면?
  - 안 돼도 충분한 의미가 있음
  - 꼬리 재귀는 반복문으로 쉽게 변경 가능!

재귀함수 -> 반복문 변경보다 어차피 꼬리 재귀함수까지 생각했다면 그걸 반복문으로 변경하는 건 거의 1:1 대응하므로 훨씬 수월하다!

Java에선 꼬리 재귀 함수 최적화 미지원. 함수형 언어들에서 주로 많이 지원.





<br>

# P 분류

## P 분류(P class)

- 판정 문제들을 분류하는 방법 중 하나
  - 판정 문제: 입력 값에 대해 예/아니오 답을 내릴 수 있는 문제
- 결정론적 튜링 기계에서 다항식 시간 안에 풀 수 있는 모든 문제 포함


## 결정론적 튜링 기계

- 튜링 기계: 무언가를 계산하는 기계를 대표하는 가상의 장치
  - 일반적인 컴퓨터 알고리듬을 수행할 수 있음
- 결정론적 튜링 기계란?
  - 어떤 명령어 실행 뒤, 다음 실행할 명령어가 확정됨
  - 코어 하나에서 명령어를 순서대로 실행한다 생각할 것
  - 즉, 코어 하나에서 실행되는 다항식 시간 알고리듬이 있는 문제는 P








<br>

# NP 분류

## NP 분류(NP class)

- NP: 비결정적 다항식 시간(nondeterministic polynomial time)
  - Not P가 아님 <- 매우 중요. 결정론적 튜링 기계인지, 비결정론적 튜링 기계인지 차이가 전부.


## 비결정론적 튜링 기계

- 어떤 명령어 실행 뒤, 다음 실행할 명령어가 확정되지 않음
- 여러 개의 다음 명령어를 ***병렬적으로*** 실행하는 기계라고 생각하길


## 결정론적 튜링 기계에서의 NP 문제

- 일단 답이 있으면 그 답이 맞는지를 다항식 시간 안에 검증할 수 있음
- 푸는 데는 지수 시간이 걸릴 수도 있음
  - 그래도 다항식 시간 안에 검증 가능


## 랜덤 접근 기계는 결정론적 튜링 기계

- 랜덤 접근 기계: 레지스터를 갖춘 CPU 1개
- 결정론적 튜링 기계
  - 어떤 명령어 실행 즉시, 다음 실행할 명령어가 확정됨
  - 코어 하나에서 명령어를 순서대로 실행한다 생각할 것
- 앞으로 별도 언급이 없으면 결정론적 튜링 기계를 의미
- NP 문제를 일반적인 방법으로 풀기에는 좀 느림
  - 대신 무작위, 근사, 휴리스틱 알고리듬 등을 이용

정리:

P 문제는 결정론적 튜링 기계에서 해법을 찾는 데에 걸리는 시간이 다항식 시간이 걸리는 알고리즘을 알고 있다.

NP 문제는 ***결정론적*** 튜링 기계에서 ***이미 있는 해법***을 ***검증하는 것***을 다항식 시간 내에 할 수 있다.

(하지만 원래 NP 문제의 정의는 ***비결정론적*** 튜링 기계에서 ***해법을*** 다항식 시간내에 ***찾을 수 있는 것***)






<br>

# P 또는 NP가 아니다!

## NP?

```java
public static boolean hasGreater(int[] nums, int k) {
    for (int i = 0; i < nums.length; ++i) {
        if (nums[i] > k) {
            return true;
        }
    }

    return false;
}
```

P이자 NP(P 또는 NP 둘 중 하나가 아니다/NP는 Not P가 아니다)! 다항식 시간 안에 풀 수 있는 문제 O(N)! 

병렬적으로 다항식 시간 안에 풀 수 있는 문제(한 코어에서 다항식 시간 안에 풀 수 있다면 병렬적으로도 마찬가지)



<br>

# NP를 다항식 시간 안에 검증할 수 있다?

## NP를 다항식 시간 안에 검증할 수 있다?

- 검증: 답이 맞는지 확인함
- 답: 각 분기마다 따라야 하는 가지들
- 다음 둘을 비교
  - 가지를 따라 명령어를 실행한 결과
  - 올바른 값
- 같으면 검증 완료

트리에서 무언가를 찾는 것은 결정론적 튜링기계에서는 시간이 많이 걸려 P가 아닐 수 있다. 하지만 이미 답이 있다면 한 단계씩 따라가기만 하면(다른 선택지들은 검색 안해도 됨) 다항식 시간 내에 검색 가능.

## P 또는 NP가 아님!

- 둘 사이의 판단 기준이 아예 다름
  - NP가 Not P가 아니라고 계속 말한 이유
- 사실 모든 P 문제는 NP

어떤 문제가 결정적 튜링기계에서 다항식 시간에 풀 수 없지만 증명/검증은 다항식 시간 안에 풀 수 있다면 해당 문제는 NP 문제.







<br>

# NP 완전, NP 난해

## NP-완전(NP-complete, NPC) 문제

- NP 문제 중 일부
- 모든 NP 문제들은 NP-완전 문제로 환원 가능
  - 그것도 다항식 시간 안에
  - 여전히 NP 문제이니 다항식 시간 안에 답 검증 가능
- 최소 다른 NP 문제들만큼 어려운 문제
- 따라서 NP 중에서도 가장 어려운 문제라고 할 수 있음





<br>

# NP-난해 (NP-hard) 문제

- 최소 NP-완전 문제만큼 어려운 문제들
- NP-완전 문제는 모두 NP-난해 문제
- NP가 아닌 문제도 있음
  - 즉, 다항식 시간 안에 답 검증이 불가능한 문제
  - 당연히 NP보다 복잡도가 높은 문제






<br>

# P vs NP 문제

## P vs NP 문제

- P 또는 NP냐를 논하는 문제가 아님
- P와 NP가 같은지 아닌지를 논하는 문제

P = NP vs. P != NP

어느 쪽이 맞을까?


## P = NP vs. P != NP

- NP-완전 문제는 NP 문제 중 가장 어려운 문제
- NP-완전 문제 중 하나라도 다항식 시간 안에 풀 수 있다면?(현재는 아직 다항식 시간 안에 풀 수 있는 알고리즘이 없지만)
  - 이 문제는 P가 됨
  - 모든 NP 문제를 NP-완전 문제로 다항식 시간 안에 환원할 수 있음
  - 따라서 모든 NP 문제가 P가 됨(P = NP)

(아직 다항식 시간 알고리즘을 발견 못했기에 P가 아닌 것!)

- P = NP가 되면 디지털 사회에 미치는 여파는?
  - 느려서 못 풀던 그 많은 문제를 효율적으로 풀 수 있음

## P vs NP 문제

- P = NP를 증명하는 방법은?
  - NP-완전 문제 중에 하나라도 다항식 시간 안에 풀면 됨
  - 발견하는 순간 이 논란은 종식
- P != NP를 증명하는 방법은?
  - 없음
  - P = NP를 증명 못하는 시간이 길어질수록 개연성만 높아짐
  - 현재 그래서 다들 P != NP라 추측 중












